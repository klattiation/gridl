<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: plugins/iterator.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: plugins/iterator.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/**
 * @callback iteratorCallback
 * @param {*} cell - The value of the current cell.
 * @param {Array.&lt;number>} position - The current position.
 * @param {gridl} gridlInstance - The current gridl instance.
 */

/**
 * @callback reducerCallback
 * @param {*} accumulator - The accumulator accumulates the callback's return values; it is the accumulated value previously returned in the last invocation of the callback, or initialValue, if supplied.
 * @param {*} cell - The value of the current cell.
 * @param {Array.&lt;number>} position - The current position.
 * @param {gridl} gridlInstance - The current gridl instance.
 */

import gridl from '../index';
import { index2pos, unflatten } from '../utils';

export default function(instance, state) {

    /**
     * Map over all cells. It's the equivalent of Array.map just for the grid.
     *
     * @memberOf gridl
     * @method
     * @instance
     *
     * @param {iteratorCallback} callback - The callback function that is called on each cell.&lt;br>&lt;code>function(cell, position, gridlInstance) { return ... }&lt;/code>
     * @returns {gridl} A new gridl instance.
     */
    function map(callback) {
        const { data, columns } = state;
        const newData = data.map((v, i) => callback(v, index2pos(i, columns), instance));
        return gridl(unflatten(newData, columns));
    }

    /**
     * Iterate over all cells. It's the equivalent of Array.forEach just for the grid.
     *
     * @memberOf gridl
     * @method
     * @instance
     *
     * @param {iteratorCallback} callback - The callback function is called for each cell.&lt;br>&lt;code>function(cell, position, gridlInstance) { return ... }&lt;/code>
     * @returns {gridl} The same gridl instance.
     */
    function forEach(callback) {
        const { data, columns } = state;
        data.forEach((v, i) => callback(v, index2pos(i, columns), instance));
        return instance;
    }

    /**
     * Applies a function against an accumulator and each element in the grid to reduce it to a single value.
     *
     * @memberOf gridl
     * @method
     * @instance
     *
     * @param {reducerCallback} callback - The callback function that is executed on each cell.&lt;br>&lt;code>function(accumulator, cell, position, gridlInstance) { return ... }&lt;/code>
     * @param {*} [initialValue=undefined] - Value to use as the first argument to the first call of the &lt;code>callback&lt;/code>. If no initial value is supplied, the first element in the grid will be used.
     * @returns {*} The value that results from the reduction.
     */
    function reduce(callback, initialValue) {
        const { data, columns } = state;
        const reducer = (acc, v, i) => callback(acc, v, index2pos(i, columns), instance);
        return arguments.length === 1 ? data.reduce(reducer) : data.reduce(reducer, initialValue);
    }

    /**
     * Fill every cells with a value. You can either provide a value or a callback function to set the value for each cell.
     *
     * @memberOf gridl
     * @method
     * @instance
     *
     * @param {(iteratorCallback|*)} callbackOrValue - Either a fixed value for each cell or a callback function to fill each cell separately.
     * @returns {gridl} The same gridl instance.
     */
    function fill(callbackOrValue) {
        const { data, columns } = state;
        if (typeof callbackOrValue === 'function') {
            data.forEach((v, i) => data[i] = callbackOrValue(v, index2pos(i, columns), instance));
        }
        else {
            data.forEach((v, i) => data[i] = callbackOrValue);
        }
        return instance;
    }

    return {
        methods: {
            map,
            forEach,
            reduce,
            fill,
        }
    };
}
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="gridl.html">gridl</a></li></ul><h3>Namespaces</h3><ul><li><a href="adjacences.html">adjacences</a></li><li><a href="directions.html">directions</a></li><li><a href="generators.html">generators</a></li><li><a href="utils.html">utils</a></li></ul><h3>Tutorials</h3><ul><li><a href="tutorial-adjacent-cells.html">adjacent-cells</a></li><li><a href="tutorial-areas.html">areas</a></li><li><a href="tutorial-clipping.html">clipping</a></li><li><a href="tutorial-cloning.html">cloning</a></li><li><a href="tutorial-columns-and-rows.html">columns-and-rows</a></li><li><a href="tutorial-cow.html">cow</a></li><li><a href="tutorial-data.html">data</a></li><li><a href="tutorial-finding.html">finding</a></li><li><a href="tutorial-flipping.html">flipping</a></li><li><a href="tutorial-generating.html">generating</a></li><li><a href="tutorial-iterating.html">iterating</a></li><li><a href="tutorial-moving.html">moving</a></li><li><a href="tutorial-navigating.html">navigating</a></li><li><a href="tutorial-plugins.html">plugins</a></li><li><a href="tutorial-rotating.html">rotating</a></li><li><a href="tutorial-size.html">size</a></li><li><a href="tutorial-swapping.html">swapping</a></li><li><a href="tutorial-values.html">values</a></li></ul><h3><a href="global.html">Global</a></h3>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.5.5</a> on Sat Mar 03 2018 10:56:07 GMT+0100 (CET)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
