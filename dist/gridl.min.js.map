{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///gridl.min.js","webpack:///webpack/bootstrap 99dc703721a26c5bef17","webpack:///./src/utils.js","webpack:///./src/index.js","webpack:///./src/directions.js","webpack:///./src/generators.js","webpack:///./src/plugins/index.js","webpack:///./src/plugins/adjacence.js","webpack:///./src/plugins/area.js","webpack:///./src/plugins/clipping.js","webpack:///./src/plugins/columns.js","webpack:///./src/plugins/finding.js","webpack:///./src/plugins/flip.js","webpack:///./src/plugins/iterator.js","webpack:///./src/plugins/moving.js","webpack:///./src/plugins/navigating.js","webpack:///./src/plugins/rotating.js","webpack:///./src/plugins/rows.js","webpack:///./src/plugins/state.js","webpack:///./src/plugins/swapping.js","webpack:///./src/plugins/value.js","webpack:///./src/adjacences.js"],"names":["root","factory","exports","module","define","amd","self","this","modules","__webpack_require__","moduleId","installedModules","i","l","call","m","c","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","n","__esModule","object","property","prototype","hasOwnProperty","p","s","_toConsumableArray","arr","Array","isArray","arr2","length","from","value","index2pos","index","columns","Math","floor","pos2index","position","flatten","array2D","reduce","res","row","concat","unflatten","array1D","cell","pos","addPositions","p1","p2","subtractPositions","limit","min","max","isNotInArea","areaSize","getValueAt","data","isNaN","setValueAt","rows","getColumn","x","map","isValidPositionFormat","Number","isSafeInteger","validateGridArray","Error","forEach","utils","default","_interopRequireDefault","obj","registerPlugins","plugins","state","_this","entries","_ref","_ref2","_slicedToArray","key","pluginFactory","plugin","type","_typeof","methods","namespace","_ref3","_ref4","k","func","gridl","initialState","directions","adjacences","generators","undefined","Symbol","iterator","constructor","sliceIterator","_arr","_n","_d","_e","_s","_i","next","done","push","err","TypeError","_utils","_utils2","_generators","_generators2","_plugins","_plugins2","_directions","_directions2","_adjacences","_adjacences2","gridlFactory","fn","freeze","UP","UP_RIGHT","RIGHT","DOWN_RIGHT","DOWN","DOWN_LEFT","LEFT","UP_LEFT","makeDataGrid","callback","arguments","parsedColumns","parseInt","parsedRows","vr","vc","column","makeDataList","parsedLength","v","makeGridl","numColumns","numRows","_index2","_index","_adjacence","_adjacence2","_area","_area2","_clipping","_clipping2","_columns","_columns2","_finding","_finding2","_flip","_flip2","_iterator","_iterator2","_moving","_moving2","_navigating","_navigating2","_rotating","_rotating2","_rows","_rows2","_state","_state2","_swapping","_swapping2","_value","_value2","adjacence","area","clipping","finding","flip","moving","navigating","rotating","swapping","context","adjacentCellsAt","ALL","includeOutsideValues","gridSize","grid","_adjacentCells","adjacentCells","direction","absPos","areaFits","anchor","_checkAreaFitsAt","areaFitsAt","getArea","size","_getAreaAt","getAreaAt","setArea","_setAreaAt","setAreaAt","findInArea","flat","areaIndex","findIndex","areaColumns","posInArea","reduceAreaAt","initialValue","_reduceAreaAt","reduceArea","posTmp","end","r","rArea","cArea","fitsHorizontally","fitsVertically","targetPos","api","hasInitialValue","reducer","acc","local","global","flattenedArea","clip","_clip","clipAt","endPoint","filter","addColumn","splice","removeColumn","find","flipY","yPos","flipX","xPos","reverse","limitedIdx","left","instance","newData","fill","callbackOrValue","moveAbs","to","_moveCell","moveCell","moveColumn","xFrom","xTo","_move","moveRel","moveRow","yFrom","yTo","fromIndex","toIndex","goto","walk","_rotate","steps","mod","rotate","y","getRow","addRow","removeRow","list","clone","swapCell","otherPosition","_swapCells","swapCells","position1","position2","swapColumns","x1","x2","_swap","swapRows","y1","y2","i1","i2","tmp","index1","index2","valueAt","ALL_CW","ALL_CCW","ORTHOGONAL","ORTHOGONAL_CW","ORTHOGONAL_CCW","DIAGONAL","DIAGONAL_CW","DIAGONAL_CCW"],"mappings":"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","file":"gridl.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"gridl\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"gridl\"] = factory();\n\telse\n\t\troot[\"gridl\"] = factory();\n})(typeof self !== 'undefined' ? self : this, function() {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"gridl\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"gridl\"] = factory();\n\telse\n\t\troot[\"gridl\"] = factory();\n})(typeof self !== 'undefined' ? self : this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 1);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\n/**\n * Calculates the position according to an index.\n *\n * @memberOf utils\n * @method\n *\n * @param {number} index - The index on a one-dimensional list array.\n * @param {number} columns - The number of columns of the two-dimensional grid array.\n * @returns {number[]} The position according to the index.\n */\nvar index2pos = exports.index2pos = function index2pos(index, columns) {\n    return [index % columns, Math.floor(index / columns)];\n};\n\n/**\n * Calculates the index according to the position.\n *\n * @memberOf utils\n * @method\n *\n * @param {number[]} position - The position on a two-dimensional array.\n * @param {number} columns - The number of columns of the two-dimensional array.\n * @returns {number} The index according to the position.\n */\nvar pos2index = exports.pos2index = function pos2index(position, columns) {\n    return position && position[0] + position[1] * columns;\n};\n\n/**\n * Converts a two-dimensional grid array into a one-dimensional list array.\n *\n * @memberOf utils\n * @method\n *\n * @param {number[][]} array2D - The two-dimensional array that should be converted.\n * @returns {number[]} A one-dimensional array.\n */\nvar flatten = exports.flatten = function flatten(array2D) {\n    return array2D.reduce(function (res, row) {\n        return [].concat(_toConsumableArray(res), _toConsumableArray(row));\n    }, []);\n};\n\n/**\n * Converts a one-dimensional list array into a two dimensional grid array.\n *\n * @memberOf utils\n * @method\n *\n * @param {number[]} array1D - The one-dimensional array you want to convert.\n * @param {number} columns - The number of columns the new two-dimensional array should have.\n * @returns {number[][]} - A two-dimensional array.\n */\nvar unflatten = exports.unflatten = function unflatten(array1D, columns) {\n    return array1D.reduce(function (res, cell, index) {\n        var pos = index2pos(index, columns);\n        if (!res[pos[1]]) {\n            res[pos[1]] = [];\n        }\n        res[pos[1]][pos[0]] = cell;\n        return res;\n    }, []);\n};\n\n/**\n * Adds the x and y values of two positions.\n *\n * @memberOf utils\n * @method\n *\n * @param {number[]} p1 - The first position.\n * @param {number[]} p2 - The second position.\n * @returns {number[]} The sum of both positions.\n */\nvar addPositions = exports.addPositions = function addPositions(p1, p2) {\n    return [p1[0] + p2[0], p1[1] + p2[1]];\n};\n\n/**\n * Subtracts the x and y value of two positions.\n *\n * @memberOf utils\n * @method\n *\n * @param {number[]} p1 - The first position.\n * @param {number[]} p2 - The second position.\n * @returns {number[]} - The difference of both positions.\n */\nvar subtractPositions = exports.subtractPositions = function subtractPositions(p1, p2) {\n    return [p1[0] - p2[0], p1[1] - p2[1]];\n};\n\n/**\n * Limits a value to be between a minimum and maximum value.\n *\n * @memberOf utils\n * @method\n *\n * @param {number} value - The value that should be limited.\n * @param {number} min - The minimum value.\n * @param {number} max - The maximum value.\n * @returns {number} The limited value.\n */\nvar limit = exports.limit = function limit(value, min, max) {\n    return Math.max(Math.min(value, max), min);\n};\n\n/**\n * Determines if a position is located within in an area.\n *\n * @memberOf utils\n * @method\n *\n * @param {number[]} areaSize - The size of the area.\n * @param {number[]} position - The position.\n * @returns {boolean} Whether or not the position is located within the area.\n */\nvar isNotInArea = exports.isNotInArea = function isNotInArea(areaSize, position) {\n    return position[0] < 0 || position[0] >= areaSize[0] || position[1] < 0 || position[1] >= areaSize[1];\n};\n\n/**\n * Get a value at a given position. This method is operating on a one-dimensional array.\n *\n * @memberOf utils\n * @method\n *\n * @param {Array.<*>} data - The one-dimensional source array.\n * @param {number} columns - The number of columns.\n * @param {number[]} pos - The position where to get the value\n * @returns {*} - The value at the given position.\n */\nvar getValueAt = exports.getValueAt = function getValueAt(data, columns, pos) {\n    var index = pos2index(pos, columns);\n    if (isNaN(index)) {\n        return;\n    }\n    return data[index];\n};\n\n/**\n * Set the value at a given position. This method is operating on a one-dimensional array.\n *\n * @memberOf utils\n * @method\n *\n * @param {Array.<*>} data - The one-dimensional source array.\n * @param {number} columns - The number of columns.\n * @param {number} rows - The number of rows.\n * @param {number[]} pos - The position where to set the value.\n * @param {*} value - The value to set.\n * @returns {boolean} - Whether or not the value was set successfully.\n */\nvar setValueAt = exports.setValueAt = function setValueAt(data, columns, rows, pos, value) {\n    if (isNotInArea([columns, rows], pos)) {\n        return false;\n    }\n    var index = pos2index(pos, columns);\n    if (!isNaN(index)) {\n        data[index] = value;\n    }\n    return true;\n};\n\n/**\n * Extracts a column at a given x position. This method operates on a one-dimensional grid array.\n *\n * @memberOf utils\n * @method\n *\n * @param {Array.<*>} data - The one-dimensional source array.\n * @param {number} x - The x position of the column.\n * @returns {Array.<*>} - The column.\n */\nvar getColumn = exports.getColumn = function getColumn(data, x) {\n    if (x >= 0 && x < data[0].length) {\n        return data.map(function (row) {\n            return row[x];\n        });\n    }\n};\n\n/**\n * Check if the position is in a valid format.\n *\n * @memberOf utils\n * @method\n *\n * @param {Array.<number>} position - The position to validate.\n * @returns {boolean} Whether or not it has a valid position format.\n */\nvar isValidPositionFormat = exports.isValidPositionFormat = function isValidPositionFormat(position) {\n    if (!Array.isArray(position) || position.length !== 2) {\n        return false;\n    }\n    return Number.isSafeInteger(position[0]) && Number.isSafeInteger(position[1]);\n};\n\n/**\n * Checks if the given data is a valid two-dimensional grid array.\n *\n * @memberOf utils\n * @method\n *\n * @param {Array.<Array.<*>>} data - The data to validate.\n */\nvar validateGridArray = exports.validateGridArray = function validateGridArray(data) {\n    if (!Array.isArray(data)) {\n        throw new Error('Trying to import data that is not an array.');\n    }\n    data.forEach(function (row, i) {\n        if (!Array.isArray(row)) {\n            throw new Error('Trying to import data that is not an array.');\n        }\n        if (i > 0 && data[i - 1].length !== row.length) {\n            throw new Error('Trying to import data with inconsistent number of columns.');\n        }\n        if (row.length < 1) {\n            throw new Error('Trying to import grid without any columns. You need to provide at least one column.');\n        }\n    });\n};\n\n/**\n * Utility functions. These methods are useful when working with gridl's internal data. You could find them helpful when\n * developing your own plugins.\n *\n * @namespace\n * @type {Object}\n */\nvar utils = {\n    flatten: flatten,\n    isValidPositionFormat: isValidPositionFormat,\n    unflatten: unflatten,\n    index2pos: index2pos,\n    pos2index: pos2index,\n    addPositions: addPositions,\n    subtractPositions: subtractPositions,\n    limit: limit,\n    isNotInArea: isNotInArea,\n    getColumn: getColumn,\n    getValueAt: getValueAt,\n    setValueAt: setValueAt,\n    validateGridArray: validateGridArray\n};\n\nexports.default = utils;\n\n/***/ }),\n/* 1 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.directions = exports.adjacences = exports.generators = exports.utils = undefined;\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\nvar _utils = __webpack_require__(0);\n\nvar _utils2 = _interopRequireDefault(_utils);\n\nvar _generators = __webpack_require__(3);\n\nvar _generators2 = _interopRequireDefault(_generators);\n\nvar _plugins = __webpack_require__(4);\n\nvar _plugins2 = _interopRequireDefault(_plugins);\n\nvar _directions = __webpack_require__(2);\n\nvar _directions2 = _interopRequireDefault(_directions);\n\nvar _adjacences = __webpack_require__(19);\n\nvar _adjacences2 = _interopRequireDefault(_adjacences);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar flatten = _utils2.default.flatten,\n    validateGridArray = _utils2.default.validateGridArray;\n\n\nfunction registerPlugins(plugins, state) {\n    var _this = this;\n\n    Object.entries(plugins).forEach(function (_ref) {\n        var _ref2 = _slicedToArray(_ref, 2),\n            key = _ref2[0],\n            pluginFactory = _ref2[1];\n\n        var plugin = pluginFactory(_this, state);\n        var type = typeof plugin === 'undefined' ? 'undefined' : _typeof(plugin);\n\n        // plugin is just a function\n        if (type === 'function') {\n            _this[key] = plugin;\n        }\n\n        // plugin returns multiple functions with a namespace\n        else if (type === 'object' && plugin.methods && plugin.namespace) {\n                _this[key] = plugin.methods;\n            }\n\n            // plugin returns multiple functions without a namespace\n            else if (type === 'object' && plugin.methods) {\n                    Object.entries(plugin.methods).forEach(function (_ref3) {\n                        var _ref4 = _slicedToArray(_ref3, 2),\n                            k = _ref4[0],\n                            func = _ref4[1];\n\n                        _this[k] = func;\n                    });\n                }\n    });\n}\n\n/**\n * @class\n * @private\n */\nfunction gridl(plugins, data) {\n\n    // validate incoming data\n    validateGridArray(data);\n\n    // create initial state\n    var initialState = {\n        rows: data.length,\n        columns: data[0].length,\n        data: flatten(data),\n        position: [0, 0]\n    };\n\n    // register plugins with initial state\n    registerPlugins.call(this, plugins, initialState);\n\n    return this;\n}\n\n/**\n * Creates a new gridl instance.\n *\n * @constructs gridl\n * @param {Array.<Array.<*>>} data - A two dimensional grid array. Every row needs to have the same length.\n */\nvar gridlFactory = function gridlFactory(data) {\n    return new gridl(_plugins2.default, data);\n};\ngridlFactory.fn = _plugins2.default;\n\nexports.utils = _utils2.default;\nexports.generators = _generators2.default;\nexports.adjacences = _adjacences2.default;\nexports.directions = _directions2.default;\nexports.default = gridlFactory;\n\n/***/ }),\n/* 2 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/**\n * Predefined directions you can walk in.<br>\n * Use it in combination with [walk(direction)]{@link gridl#walk}.\n *\n * @namespace\n *\n * @type {Object}\n * @property {Array.<number>} UP - one step up\n * @property {Array.<number>} UP_LEFT - one step left, one step up\n * @property {Array.<number>} UP_RIGHT - one step right, one step up\n * @property {Array.<number>} RIGHT - one step right\n * @property {Array.<number>} LEFT - one step left\n * @property {Array.<number>} DOWN - one step down\n * @property {Array.<number>} DOWN_LEFT - one step left, one step down\n * @property {Array.<number>} DOWN_RIGHT - one step right, one step down\n */\nvar directions = Object.freeze({\n  UP: Object.freeze([0, -1]),\n  UP_RIGHT: Object.freeze([1, -1]),\n  RIGHT: Object.freeze([1, 0]),\n  DOWN_RIGHT: Object.freeze([1, 1]),\n  DOWN: Object.freeze([0, 1]),\n  DOWN_LEFT: Object.freeze([-1, 1]),\n  LEFT: Object.freeze([-1, 0]),\n  UP_LEFT: Object.freeze([-1, -1])\n});\n\nexports.default = directions;\nmodule.exports = exports[\"default\"];\n\n/***/ }),\n/* 3 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.makeDataGrid = makeDataGrid;\nexports.makeDataList = makeDataList;\nexports.makeGridl = makeGridl;\n\nvar _index = __webpack_require__(1);\n\nvar _index2 = _interopRequireDefault(_index);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * Create a two dimensional grid array.\n *\n * @memberOf generators\n * @param {number} columns - The number of columns.\n * @param {number} rows - The number of rows.\n * @param {Function} callback - The generator function that is called on each cell.\n * @returns {Array.<Array.<*>>} The new grid array.\n */\nfunction makeDataGrid(columns, rows) {\n    var callback = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : function () {\n        return null;\n    };\n\n    var parsedColumns = parseInt(columns);\n    var parsedRows = parseInt(rows);\n    if (parsedColumns < 1 || isNaN(parsedColumns)) {\n        throw new Error('You need to specify at least one column. Given: ' + columns);\n    }\n    if (parsedRows < 1 || isNaN(parsedRows)) {\n        throw new Error('You need to specify at least one row. Given: ' + rows);\n    }\n    return Array.from({ length: parsedRows }, function (vr, row) {\n        return Array.from({ length: parsedColumns }, function (vc, column) {\n            return callback({ column: column, row: row });\n        });\n    });\n}\n\n/**\n * Generate a one-dimensional array that can be a single row or column.\n *\n * @memberOf generators\n * @param {number} length - The length of the array.\n * @param {Function} callback - The generator callback function that is called on each element.\n * @returns {Array.<*>}\n */\nfunction makeDataList(length) {\n    var callback = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : function () {\n        return null;\n    };\n\n    var parsedLength = parseInt(length);\n    if (parsedLength < 1 || isNaN(parsedLength)) {\n        throw new Error('Trying to make a list with an invalid length. Given: ' + length);\n    }\n    return Array.from({ length: parsedLength }, function (v, i) {\n        return callback(i);\n    });\n}\n\n/**\n * Generate a gridl instance from scratch by specifying the number of rows and columns and fill it with values.\n *\n * @memberOf generators\n * @param {number} numColumns - The number of columns.\n * @param {number} numRows - The number of rows.\n * @param {Function} callback - The generator function that is called for each cell. The returned value is going to be the value of the cell.\n * @returns {gridl} A new gridl instance\n */\nfunction makeGridl(numColumns, numRows, callback) {\n    return (0, _index2.default)(makeDataGrid(numColumns, numRows, callback));\n}\n\n/**\n * @namespace generators\n */\nexports.default = {\n    makeGridl: makeGridl,\n    makeDataGrid: makeDataGrid,\n    makeDataList: makeDataList\n};\n\n/***/ }),\n/* 4 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _adjacence = __webpack_require__(5);\n\nvar _adjacence2 = _interopRequireDefault(_adjacence);\n\nvar _area = __webpack_require__(6);\n\nvar _area2 = _interopRequireDefault(_area);\n\nvar _clipping = __webpack_require__(7);\n\nvar _clipping2 = _interopRequireDefault(_clipping);\n\nvar _columns = __webpack_require__(8);\n\nvar _columns2 = _interopRequireDefault(_columns);\n\nvar _finding = __webpack_require__(9);\n\nvar _finding2 = _interopRequireDefault(_finding);\n\nvar _flip = __webpack_require__(10);\n\nvar _flip2 = _interopRequireDefault(_flip);\n\nvar _iterator = __webpack_require__(11);\n\nvar _iterator2 = _interopRequireDefault(_iterator);\n\nvar _moving = __webpack_require__(12);\n\nvar _moving2 = _interopRequireDefault(_moving);\n\nvar _navigating = __webpack_require__(13);\n\nvar _navigating2 = _interopRequireDefault(_navigating);\n\nvar _rotating = __webpack_require__(14);\n\nvar _rotating2 = _interopRequireDefault(_rotating);\n\nvar _rows = __webpack_require__(15);\n\nvar _rows2 = _interopRequireDefault(_rows);\n\nvar _state = __webpack_require__(16);\n\nvar _state2 = _interopRequireDefault(_state);\n\nvar _swapping = __webpack_require__(17);\n\nvar _swapping2 = _interopRequireDefault(_swapping);\n\nvar _value = __webpack_require__(18);\n\nvar _value2 = _interopRequireDefault(_value);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nexports.default = {\n    adjacence: _adjacence2.default,\n    area: _area2.default,\n    clipping: _clipping2.default,\n    columns: _columns2.default,\n    finding: _finding2.default,\n    flip: _flip2.default,\n    iterator: _iterator2.default,\n    moving: _moving2.default,\n    navigating: _navigating2.default,\n    rotating: _rotating2.default,\n    rows: _rows2.default,\n    state: _state2.default,\n    swapping: _swapping2.default,\n    value: _value2.default\n};\nmodule.exports = exports['default'];\n\n/***/ }),\n/* 5 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nexports.default = function (context, state) {\n\n    /**\n     * Get the values of all adjacent cells at a given position.\n     *\n     * @memberOf gridl\n     * @method\n     * @instance\n     *\n     * @param {number[]} position - The position of the cell of which you want to know its adjacent cells.\n     * @param {number[][]} [adjacence = [adjacents.ALL]{@link adjacences}] - A list of positions relative to the given position. These positions are considered as the adjacents.\n     * @param {boolean} [includeOutsideValues = false] - If <code>false</code>, adjacent cells that are outside the grid will be ignored, if <code>true</code>, <code>undefined</code> will be returned for them.\n     * @returns {Array.<*>} The values of the adjacent cells.\n     */\n    function adjacentCellsAt(position) {\n        var adjacence = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _index.adjacences.ALL;\n        var includeOutsideValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n        var data = state.data,\n            columns = state.columns,\n            rows = state.rows;\n\n        var gridSize = !includeOutsideValues && [columns, rows];\n        var grid = (0, _utils.unflatten)(data, columns);\n        return _adjacentCells(grid, position, adjacence, gridSize);\n    }\n\n    /**\n     * Get the values of all adjacent cells at the current position.<br>\n     * The current position can be defined by [goto(position)]{@link gridl#goto} or [walk(direction)]{@link gridl#walk}.\n     *\n     * @memberOf gridl\n     * @method\n     * @instance\n     *\n     * @param {number[][]} [adjacence = [adjacents.ALL]{@link adjacences}] - A list of positions relative to the given position. These positions are considered as the adjacents.\n     * @param {boolean} [includeOutsideValues = false] - If <code>false</code>, adjacent cells that are outside the grid will be ignored, if <code>true</code>, <code>undefined</code> will be returned for them.\n     * @returns {Array.<*>} The values of the adjacent cells.\n     */\n    function adjacentCells() {\n        var adjacence = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : _index.adjacences.ALL;\n        var includeOutsideValues = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n        var data = state.data,\n            columns = state.columns,\n            rows = state.rows,\n            position = state.position;\n\n        var gridSize = !includeOutsideValues && [columns, rows];\n        var grid = (0, _utils.unflatten)(data, columns);\n        return _adjacentCells(grid, position, adjacence, gridSize);\n    }\n\n    return {\n        methods: {\n            adjacentCells: adjacentCells,\n            adjacentCellsAt: adjacentCellsAt\n        }\n    };\n};\n\nvar _index = __webpack_require__(1);\n\nvar _index2 = _interopRequireDefault(_index);\n\nvar _utils = __webpack_require__(0);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\nvar _adjacentCells = function _adjacentCells(grid, position, adjacence) {\n    var gridSize = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n\n    return adjacence.reduce(function (res, direction) {\n        var absPos = (0, _utils.addPositions)(position, direction);\n        var value = grid && grid[absPos[1]] && grid[absPos[1]][absPos[0]];\n        if (gridSize) {\n            return (0, _utils.isNotInArea)(gridSize, absPos) ? res : [].concat(_toConsumableArray(res), [value]);\n        } else {\n            return [].concat(_toConsumableArray(res), [value]);\n        }\n    }, []);\n};\n\nmodule.exports = exports['default'];\n\n/***/ }),\n/* 6 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nexports.default = function (context, state) {\n\n    /**\n     * Check if a given area would fit inside the grid at the current position.<br>\n     * The current position can be defined by [goto(position)]{@link gridl#goto} or [walk(direction)]{@link gridl#walk}.\n     *\n     * @memberOf gridl\n     * @method\n     * @instance\n     *\n     * @param {Array.<Array.<*>>} area - The area itself as a two-dimensional grid array\n     * @param {number[]} [anchor = [0, 0]] - The center of area.\n     * @returns {boolean} Whether the area fits or not.\n     */\n    function areaFits(area, anchor) {\n        var columns = state.columns,\n            rows = state.rows,\n            position = state.position;\n\n        return _checkAreaFitsAt(columns, rows, position, area, anchor);\n    }\n\n    /**\n     * Check if a given area would fit inside the grid at a given position.\n     *\n     * @memberOf gridl\n     * @method\n     * @instance\n     *\n     * @param {number[]} position - The position where the area should be placed.\n     * @param {Array.<Array.<*>>} area - The area itself as a two-dimensional grid array\n     * @param {number[]} [anchor = [0, 0]] - The center of area.\n     * @returns {boolean} Whether the area fits or not.\n     */\n    function areaFitsAt(position, area, anchor) {\n        var columns = state.columns,\n            rows = state.rows;\n\n        return _checkAreaFitsAt(columns, rows, position, area, anchor);\n    }\n\n    /**\n     * Exports the data grid array of a given array at the current position.<br>\n     * The current position can be defined by [goto(position)]{@link gridl#goto} or [walk(direction)]{@link gridl#walk}.\n     *\n     * @memberOf gridl\n     * @method\n     * @instance\n     *\n     * @param {Array.<number>} size - The size fo the area as a two-dimensional grid array.\n     * @param {Array.<number>} [anchor = [0, 0]] - The center of area.\n     * @returns {Array.<Array.<*>>} The area.\n     */\n    function getArea(size, anchor) {\n        var data = state.data,\n            columns = state.columns,\n            rows = state.rows,\n            position = state.position;\n\n        return _getAreaAt(data, columns, rows, position, size, anchor);\n    }\n\n    /**\n     * Exports the data grid array of a given array at the given position.\n     *\n     * @memberOf gridl\n     * @method\n     * @instance\n     *\n     * @param {Array.<number>} position - The position of the area.\n     * @param {Array.<number>} size - The size fo the area as a two-dimensional grid array.\n     * @param {Array.<number>} [anchor = [0, 0]] - The center of area.\n     * @returns {Array.<Array.<*>>} The area.\n     */\n    function getAreaAt(position, size, anchor) {\n        var data = state.data,\n            columns = state.columns,\n            rows = state.rows;\n\n        return _getAreaAt(data, columns, rows, position, size, anchor);\n    }\n\n    /**\n     * Overwrite the values of a given area at the current position.<br>\n     * The current position can be defined by [goto(position)]{@link gridl#goto} or [walk(direction)]{@link gridl#walk}.\n     *\n     * @memberOf gridl\n     * @method\n     * @instance\n     *\n     * @param {Array.<number>} area - The area itself as two-dimensional grid array.\n     * @param {Array.<number>} [anchor = [0, 0]] - The center of area.\n     * @returns {gridl} The same gridl instance.\n     */\n    function setArea(area, anchor) {\n        var data = state.data,\n            columns = state.columns,\n            rows = state.rows,\n            position = state.position;\n\n        _setAreaAt(data, columns, rows, position, area, anchor);\n        return context;\n    }\n\n    /**\n     * Overwrite the values of a given area at a certain position.\n     *\n     * @memberOf gridl\n     * @method\n     * @instance\n     *\n     * @param {Array.<number>} position - The position of the area.\n     * @param {Array.<number>} area - The area itself as two-dimensional grid array.\n     * @param {Array.<number>} [anchor = [0, 0]] - The center of area.\n     * @returns {gridl} The same gridl instance.\n     */\n    function setAreaAt(position, area, anchor) {\n        var data = state.data,\n            columns = state.columns,\n            rows = state.rows;\n\n        _setAreaAt(data, columns, rows, position, area, anchor);\n        return context;\n    }\n\n    /**\n     * Find the first occurrence of an element within a certain area.\n     *\n     * @memberOf gridl\n     * @method\n     * @instance\n     *\n     * @param {Array} position - The position of the area [x, y].\n     * @param {Array} size - The size of the area [columns, rows].\n     * @param {iteratorCallback} callback - The callback function that is called on each element within the defined area. Should return true if the element is found or false if not.\n     * @returns {(Array.<number>|undefined)} The position of the first element that is found or <code>undefined</code> if nothing was found.\n     */\n    function findInArea(position, size, callback) {\n        var data = state.data,\n            columns = state.columns,\n            rows = state.rows;\n\n        var area = _getAreaAt(data, columns, rows, position, size);\n        var flat = (0, _utils.flatten)(area);\n        var areaIndex = flat.findIndex(function (v, i) {\n            return callback(v, (0, _utils.index2pos)(i, columns), context);\n        });\n        if (areaIndex < 0) {\n            return;\n        }\n        var areaColumns = area[0].length;\n        var posInArea = (0, _utils.index2pos)(areaIndex, areaColumns);\n        return [position[0] + posInArea[0], position[1] + posInArea[1]];\n    }\n\n    /**\n     * Applies a function against an accumulator and each element in the area at a given position to reduce it to a single value.\n     *\n     * @memberOf gridl\n     * @method\n     * @instance\n     *\n     * @param {number[][]} position - The position of the area within the grid.\n     * @param {number[][]} size - The size of the area within the grid.\n     * @param {reducerCallback} callback - The callback function that is executed on each cell within the grid.\n     * @param {*} [initialValue=undefined] - Value to use as the first argument to the first call of the <code>callback</code>. If no initial value is supplied, the first element in the grid will be used.\n     * @returns {*} The value that results from the reduction.\n     */\n    function reduceAreaAt(position, size, callback, initialValue) {\n        var data = state.data,\n            columns = state.columns,\n            rows = state.rows;\n\n        return _reduceAreaAt(context, data, columns, rows, position, size, callback, initialValue, arguments.length === 1);\n    }\n\n    /**\n     * Applies a function against an accumulator and each element in the area at the current position to reduce it to a single value.\n     *\n     * @memberOf gridl\n     * @method\n     * @instance\n     *\n     * @param {number[][]} size - The size of the area within the grid.\n     * @param {reducerCallback} callback - The callback function that is executed on each cell within the grid.\n     * @param {*} [initialValue=undefined] - Value to use as the first argument to the first call of the <code>callback</code>. If no initial value is supplied, the first element in the grid will be used.\n     * @returns {*} The value that results from the reduction.\n     */\n    function reduceArea(size, callback, initialValue) {\n        var data = state.data,\n            columns = state.columns,\n            rows = state.rows,\n            position = state.position;\n\n        return _reduceAreaAt(context, data, columns, rows, position, size, callback, initialValue, arguments.length === 1);\n    }\n\n    return {\n        methods: {\n            areaFits: areaFits,\n            areaFitsAt: areaFitsAt,\n            getArea: getArea,\n            getAreaAt: getAreaAt,\n            setArea: setArea,\n            setAreaAt: setAreaAt,\n            findInArea: findInArea,\n            reduceArea: reduceArea,\n            reduceAreaAt: reduceAreaAt\n        }\n    };\n};\n\nvar _index = __webpack_require__(1);\n\nvar _index2 = _interopRequireDefault(_index);\n\nvar _utils = __webpack_require__(0);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar _getAreaAt = function _getAreaAt(data, columns, rows, position, size) {\n    var anchor = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : [0, 0];\n\n    var posTmp = (0, _utils.subtractPositions)(position, anchor);\n    var end = [Math.min(posTmp[0] + size[0], columns), Math.min(posTmp[1] + size[1], rows)];\n    var pos = [Math.max(0, posTmp[0]), Math.max(0, posTmp[1])];\n    var area = [];\n    for (var r = pos[1]; r < end[1]; r++) {\n        var rArea = r - pos[1];\n        if (!area[rArea]) {\n            area[rArea] = [];\n        }\n        for (var c = pos[0]; c < end[0]; c++) {\n            var cArea = c - pos[0];\n            area[rArea][cArea] = (0, _utils.getValueAt)(data, columns, [c, r]);\n        }\n    }\n    return area;\n};\n\nvar _checkAreaFitsAt = function _checkAreaFitsAt(columns, rows, position, area) {\n    var anchor = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : [0, 0];\n\n    var pos = (0, _utils.subtractPositions)(position, anchor);\n    var fitsHorizontally = pos[0] >= 0 && pos[0] + area[0].length <= columns;\n    var fitsVertically = pos[1] >= 0 && pos[1] + area.length <= rows;\n    return fitsHorizontally && fitsVertically;\n};\n\nvar _setAreaAt = function _setAreaAt(data, columns, rows, position, area) {\n    var anchor = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : [0, 0];\n\n    var pos = (0, _utils.subtractPositions)(position, anchor);\n    area.forEach(function (row, r) {\n        var targetPos = [0, r + pos[1]];\n        if (targetPos[1] >= rows) {\n            return;\n        }\n        row.forEach(function (cell, c) {\n            targetPos[0] = c + pos[0];\n            if (targetPos[0] >= columns) {\n                return;\n            }\n            (0, _utils.setValueAt)(data, columns, rows, targetPos, cell);\n        });\n    });\n    return data;\n};\n\nvar _reduceAreaAt = function _reduceAreaAt(api, data, columns, rows, position, size, callback, initialValue, hasInitialValue) {\n    if (!(0, _utils.isValidPositionFormat)(position)) {\n        throw new Error('Trying to reduce an area at an invalid position.');\n    }\n    if (!(0, _utils.isValidPositionFormat)(size)) {\n        throw new Error('Trying to reduce an area with invalid size.');\n    }\n    var reducer = function reducer(acc, v, i) {\n        var local = (0, _utils.index2pos)(i, size[0]);\n        var global = (0, _utils.addPositions)(local, position);\n        return callback(acc, v, global, api);\n    };\n    var flattenedArea = (0, _utils.flatten)(_getAreaAt(data, columns, rows, position, size));\n    return hasInitialValue ? flattenedArea.reduce(reducer) : flattenedArea.reduce(reducer, initialValue);\n};\n\nmodule.exports = exports['default'];\n\n/***/ }),\n/* 7 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nexports.default = function (context, state) {\n\n    /**\n     * Clip an area out of the current grid. It removes all cells that are not inside the given area.\n     *\n     * @memberOf gridl\n     * @method\n     * @instance\n     *\n     * @param {Array.<number>} size - The size of the area.\n     * @returns {gridl} The same gridl instance.\n     */\n    function clip(size) {\n        var data = state.data,\n            columns = state.columns,\n            rows = state.rows,\n            position = state.position;\n\n        var grid = _clip(data, columns, rows, position, size);\n        state.data = (0, _utils.flatten)(grid);\n        state.rows = grid.length;\n        state.columns = grid[0].length;\n        return context;\n    }\n\n    /**\n     * Clip an area out of the current grid. It removes all cells that are not inside the given area.\n     *\n     * @memberOf gridl\n     * @method\n     * @instance\n     *\n     * @param {Array.<number>} position - The position the area.\n     * @param {Array.<number>} size - The size of the area.\n     * @returns {gridl} The same gridl instance.\n     */\n    function clipAt(position, size) {\n        var data = state.data,\n            columns = state.columns,\n            rows = state.rows;\n\n        var grid = _clip(data, columns, rows, position, size);\n        state.data = (0, _utils.flatten)(grid);\n        state.rows = grid.length;\n        state.columns = grid[0].length;\n        return context;\n    }\n\n    return {\n        methods: { clip: clip, clipAt: clipAt }\n    };\n};\n\nvar _utils = __webpack_require__(0);\n\nvar _clip = function _clip(data, columns, rows, position, size) {\n    if (position[0] < 0 || position[0] >= columns || position[1] < 0 || position[1] >= rows) {\n        throw new Error('Trying to clip data at an invalid position. Given: ' + position);\n    }\n    var endPoint = (0, _utils.addPositions)(position, size);\n    return (0, _utils.unflatten)(data, columns).filter(function (row, r) {\n        return r >= position[1] && r < endPoint[1];\n    }).map(function (row) {\n        return row.filter(function (cell, c) {\n            return c >= position[0] && c < endPoint[0];\n        });\n    });\n};\n\nmodule.exports = exports['default'];\n\n/***/ }),\n/* 8 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nexports.default = function (context, state) {\n\n    /**\n     * Get the number of columns.\n     *\n     * @memberOf gridl\n     * @method\n     * @instance\n     * @returns {number}\n     */\n    function numColumns() {\n        return state.columns;\n    }\n\n    /**\n     * Get the column at a certain x-position.\n     *\n     * @memberOf gridl\n     * @method\n     * @instance\n     *\n     * @param {number} x - The x-position of the column you want to get.\n     * @returns {Array.<*>}\n     */\n    function column(x) {\n        var data = state.data,\n            columns = state.columns;\n\n        return (0, _utils.getColumn)((0, _utils.unflatten)(data, columns), x);\n    }\n\n    /**\n     * Add a column at a certain x-position. This changes the size of the grid.\n     *\n     * @memberOf gridl\n     * @method\n     * @instance\n     *\n     * @param {Array.<*>} column - The column you want to add as an one-dimensional array.\n     * @param {number} x - The x-position of where you want to add the column.\n     * @returns {gridl} The same gridl instance.\n     */\n    function addColumn(column, x) {\n        var data = state.data,\n            columns = state.columns,\n            rows = state.rows;\n\n        if (x < 0 || x > columns) {\n            throw new Error('Trying to add column at an invalid position. Given: ' + x);\n        }\n        if (column.length !== rows) {\n            throw new Error('Trying to add a column that contains an invalid amount of cells. Expected: ' + rows + ', Given: ' + column.length);\n        }\n        var grid = _utils2.default.unflatten(data, columns).map(function (row, i) {\n            row.splice(x, 0, column[i]);\n            return row;\n        });\n        state.data = _utils2.default.flatten(grid);\n        state.columns = grid[0].length;\n        return context;\n    }\n\n    /**\n     * Remove a column at a certain x-position. This changes the size of the grid.\n     *\n     * @memberOf gridl\n     * @method\n     * @instance\n     *\n     * @param {number} x - The x-position of the column you want to remove.\n     * @returns {gridl} The same gridl instance.\n     */\n    function removeColumn(x) {\n        var data = state.data,\n            columns = state.columns;\n\n        if (x < 0 || x >= columns) {\n            throw new Error('Trying to remove a column at an invalid position. Given: ' + x);\n        }\n        if (columns <= 1) {\n            throw new Error('Cannot remove column because the grid would be empty after it.');\n        }\n        var grid = (0, _utils.unflatten)(data, columns).map(function (row) {\n            return row.filter(function (v, c) {\n                return c !== x;\n            });\n        });\n        state.data = (0, _utils.flatten)(grid);\n        state.columns = grid[0].length;\n        return context;\n    }\n\n    return {\n        methods: {\n            addColumn: addColumn,\n            column: column,\n            numColumns: numColumns,\n            removeColumn: removeColumn\n        }\n    };\n};\n\nvar _index = __webpack_require__(1);\n\nvar _index2 = _interopRequireDefault(_index);\n\nvar _utils = __webpack_require__(0);\n\nvar _utils2 = _interopRequireDefault(_utils);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nmodule.exports = exports['default'];\n\n/***/ }),\n/* 9 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nexports.default = function (context, state) {\n\n    /**\n     * Find the first occurrence of an element within the entire grid.\n     *\n     * @memberOf gridl\n     * @method\n     * @instance\n     *\n     * @param {iteratorCallback} callback - The callback function that is called on each element. Should return true if the element is found or false if not.\n     * @returns {(Array.<number>|undefined)} The position of the first element that is found or <code>undefined</code> if nothing was found.\n     */\n    function find(callback) {\n        var data = state.data,\n            columns = state.columns;\n\n        var index = data.findIndex(function (v, i) {\n            return callback(v, (0, _utils.index2pos)(i, columns), context);\n        });\n        return index >= 0 ? (0, _utils.index2pos)(index, columns) : undefined;\n    }\n\n    return { methods: { find: find } };\n};\n\nvar _utils = __webpack_require__(0);\n\nmodule.exports = exports['default'];\n\n/***/ }),\n/* 10 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nexports.default = function (context, state) {\n\n    /**\n     * Flips the array on the given x-position\n     *\n     * @param {number} xPos - The x-position of where to flip the array.\n     * @returns {gridl} The same gridl instance.\n     */\n    var flipX = function flipX(xPos) {\n        var data = state.data,\n            columns = state.columns;\n\n        var grid = (0, _utils.unflatten)(data, columns);\n        state.data = (0, _utils.flatten)(_flip(grid, xPos));\n        return context;\n    };\n\n    /**\n     * Flips the array on the given y-position.\n     *\n     * @param {number} yPos - The y-position of where to flip the array.\n     * @returns {gridl} The same gridl instance.\n     */\n    function flipY(yPos) {\n        var data = state.data,\n            columns = state.columns;\n\n        var grid = (0, _utils.unflatten)(data, columns);\n        state.data = (0, _utils.flatten)(grid.map(function (row) {\n            return _flip(row, yPos);\n        }));\n        return context;\n    }\n\n    return {\n        methods: { flipX: flipX, flipY: flipY }\n    };\n};\n\nvar _utils = __webpack_require__(0);\n\nfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\nvar _flip = function _flip(arr, index) {\n    if (index === undefined) {\n        return arr.reverse();\n    }\n    var limitedIdx = (0, _utils.limit)(index, 0, arr.length - 1);\n    var left = arr.filter(function (v, i) {\n        return i < limitedIdx;\n    });\n    var right = arr.filter(function (v, i) {\n        return i > limitedIdx;\n    });\n    return [].concat(_toConsumableArray(right.reverse()), [arr[limitedIdx]], _toConsumableArray(left.reverse()));\n};\n\nmodule.exports = exports['default'];\n\n/***/ }),\n/* 11 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nexports.default = function (instance, state) {\n\n    /**\n     * Map over all cells. It's the equivalent of Array.map just for the grid.\n     *\n     * @memberOf gridl\n     * @method\n     * @instance\n     *\n     * @param {iteratorCallback} callback - The callback function that is called on each cell.<br><code>function(cell, position, gridlInstance) { return ... }</code>\n     * @returns {gridl} A new gridl instance.\n     */\n    function map(callback) {\n        var data = state.data,\n            columns = state.columns;\n\n        var newData = data.map(function (v, i) {\n            return callback(v, (0, _utils.index2pos)(i, columns), instance);\n        });\n        return (0, _index2.default)((0, _utils.unflatten)(newData, columns));\n    }\n\n    /**\n     * Iterate over all cells. It's the equivalent of Array.forEach just for the grid.\n     *\n     * @memberOf gridl\n     * @method\n     * @instance\n     *\n     * @param {iteratorCallback} callback - The callback function is called for each cell.<br><code>function(cell, position, gridlInstance) { return ... }</code>\n     * @returns {gridl} The same gridl instance.\n     */\n    function forEach(callback) {\n        var data = state.data,\n            columns = state.columns;\n\n        data.forEach(function (v, i) {\n            return callback(v, (0, _utils.index2pos)(i, columns), instance);\n        });\n        return instance;\n    }\n\n    /**\n     * Applies a function against an accumulator and each element in the grid to reduce it to a single value.\n     *\n     * @memberOf gridl\n     * @method\n     * @instance\n     *\n     * @param {reducerCallback} callback - The callback function that is executed on each cell.<br><code>function(accumulator, cell, position, gridlInstance) { return ... }</code>\n     * @param {*} [initialValue=undefined] - Value to use as the first argument to the first call of the <code>callback</code>. If no initial value is supplied, the first element in the grid will be used.\n     * @returns {*} The value that results from the reduction.\n     */\n    function reduce(callback, initialValue) {\n        var data = state.data,\n            columns = state.columns;\n\n        var reducer = function reducer(acc, v, i) {\n            return callback(acc, v, (0, _utils.index2pos)(i, columns), instance);\n        };\n        return arguments.length === 1 ? data.reduce(reducer) : data.reduce(reducer, initialValue);\n    }\n\n    /**\n     * Fill every cells with a value. You can either provide a value or a callback function to set the value for each cell.\n     *\n     * @memberOf gridl\n     * @method\n     * @instance\n     *\n     * @param {(iteratorCallback|*)} callbackOrValue - Either a fixed value for each cell or a callback function to fill each cell separately.\n     * @returns {gridl} The same gridl instance.\n     */\n    function fill(callbackOrValue) {\n        var data = state.data,\n            columns = state.columns;\n\n        if (typeof callbackOrValue === 'function') {\n            data.forEach(function (v, i) {\n                return data[i] = callbackOrValue(v, (0, _utils.index2pos)(i, columns), instance);\n            });\n        } else {\n            data.forEach(function (v, i) {\n                return data[i] = callbackOrValue;\n            });\n        }\n        return instance;\n    }\n\n    return {\n        methods: {\n            map: map,\n            forEach: forEach,\n            reduce: reduce,\n            fill: fill\n        }\n    };\n};\n\nvar _index = __webpack_require__(1);\n\nvar _index2 = _interopRequireDefault(_index);\n\nvar _utils = __webpack_require__(0);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nmodule.exports = exports['default']; /**\n                                      * @callback iteratorCallback\n                                      * @param {*} cell - The value of the current cell.\n                                      * @param {Array.<number>} position - The current position.\n                                      * @param {gridl} gridlInstance - The current gridl instance.\n                                      */\n\n/**\n * @callback reducerCallback\n * @param {*} accumulator - The accumulator accumulates the callback's return values; it is the accumulated value previously returned in the last invocation of the callback, or initialValue, if supplied.\n * @param {*} cell - The value of the current cell.\n * @param {Array.<number>} position - The current position.\n * @param {gridl} gridlInstance - The current gridl instance.\n */\n\n/***/ }),\n/* 12 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nexports.default = function (context, state) {\n\n    /**\n     * Move the current cell to an absolute position.\n     * The current position can be defined by [goto(position)]{@link gridl#goto} or [walk(direction)]{@link gridl#walk}.\n     *\n     * @memberOf gridl\n     * @method\n     * @instance\n     *\n     * @param {Array} to - The position where the cell should be moved.\n     * @returns {gridl}\n     */\n    function moveAbs(to) {\n        var data = state.data,\n            columns = state.columns,\n            rows = state.rows,\n            position = state.position;\n\n        state.data = _moveCell(data, columns, rows, position, to);\n        return context;\n    }\n\n    /**\n     * Move a cell from one position to another.\n     *\n     * @memberOf gridl\n     * @method\n     * @instance\n     *\n     * @param {Array} from - The position of the cell that you want to move.\n     * @param {Array} to - The position where the cell should be moved.\n     * @returns {gridl} - The current gridl instance.\n     */\n    function moveCell(from, to) {\n        var data = state.data,\n            columns = state.columns,\n            rows = state.rows;\n\n        state.data = _moveCell(data, columns, rows, from, to);\n        return context;\n    }\n\n    /**\n     * Move a column to a certain position.\n     *\n     * @memberOf gridl\n     * @method\n     * @instance\n     *\n     * @param {number} xFrom - The position on the x-axis of the column you want to move.\n     * @param {number} xTo - The position on the x-axis of where the column should be moved.\n     * @returns {gridl}\n     */\n    function moveColumn(xFrom, xTo) {\n        var data = state.data,\n            columns = state.columns;\n\n        if (xFrom < 0 || xFrom >= columns) {\n            throw new Error('Trying to move column from an invalid position. Given: ' + xFrom);\n        }\n        if (xTo < 0 || xTo >= columns) {\n            throw new Error('Trying to move column to an invalid position. Given: ' + xTo);\n        }\n        state.data = (0, _utils.flatten)((0, _utils.unflatten)(data, columns).map(function (row) {\n            return _move(row, xFrom, xTo);\n        }));\n        return context;\n    }\n\n    /**\n     * Move the current cell from the current position in a certain direction.\n     * The current position can be defined by [goto(position)]{@link gridl#goto} or [walk(direction)]{@link gridl#walk}.\n     *\n     * @memberOf gridl\n     * @method\n     * @instance\n     *\n     * @param {Array} direction - The direction in which to move from the current position.\n     * @returns {gridl} The current gridl instance.\n     */\n    function moveRel(direction) {\n        var data = state.data,\n            columns = state.columns,\n            rows = state.rows,\n            position = state.position;\n\n        state.data = _moveCell(data, columns, rows, position, (0, _utils.addPositions)(position, direction));\n        return context;\n    }\n\n    /**\n     * Move a row to a certain position.\n     *\n     * @memberOf gridl\n     * @method\n     * @instance\n     *\n     * @param {number} yFrom - The position on the y-axis of the row you want to move.\n     * @param {number} yTo - The position on the y-axis of where the row should be moved to.\n     * @returns {gridl} The current gridl instance.\n     */\n    function moveRow(yFrom, yTo) {\n        var data = state.data,\n            columns = state.columns,\n            rows = state.rows;\n\n        if (yFrom < 0 || yFrom >= rows) {\n            throw new Error('Trying to move row from an invalid position. Given: ' + yFrom);\n        }\n        if (yTo < 0 || yTo >= rows) {\n            throw new Error('Trying to move row to an invalid position. Given: ' + yTo);\n        }\n        state.data = (0, _utils.flatten)(_move((0, _utils.unflatten)(data, columns), yFrom, yTo));\n        return context;\n    }\n\n    return {\n        methods: {\n            moveAbs: moveAbs,\n            moveCell: moveCell,\n            moveColumn: moveColumn,\n            moveRel: moveRel,\n            moveRow: moveRow\n        }\n    };\n};\n\nvar _utils = __webpack_require__(0);\n\nvar _move = function _move(data, fromIndex, toIndex) {\n    var cell = data[fromIndex];\n    data.splice(fromIndex, 1);\n    data.splice(toIndex, 0, cell);\n    return data;\n};\n\nvar _moveCell = function _moveCell(data, columns, rows, from, to) {\n    var fromIndex = (0, _utils.pos2index)(from, columns);\n    var size = [columns, rows];\n    if (isNaN(fromIndex) || (0, _utils.isNotInArea)(size, from)) {\n        throw new Error('Trying to move cell from an invalid position. Given: [' + from + ']');\n    }\n    var toIndex = (0, _utils.pos2index)(to, columns);\n    if (isNaN(toIndex) || (0, _utils.isNotInArea)(size, to)) {\n        throw new Error('Trying to move cell to an invalid position. Given: [' + to + ']');\n    }\n    return _move(data, fromIndex, toIndex);\n};\n\nmodule.exports = exports['default'];\n\n/***/ }),\n/* 13 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nexports.default = function (context, state) {\n\n    /**\n     * Get the current position.\n     *\n     * @returns {Array} The current position array [column, row].\n     */\n    function position() {\n        var position = state.position;\n\n        return [position[0], position[1]];\n    }\n\n    /**\n     * Go to an absolute position.\n     * The internal cursor will be set to this position and can then be used for further operations.\n     *\n     * @memberOf gridl\n     * @method\n     * @instance\n     *\n     * @param {Array} position - The new position.\n     * @returns {gridl}\n     */\n    function goto(position) {\n        if (!(0, _utils.isValidPositionFormat)(position)) {\n            throw new Error('Trying to go to an invalid position. Given: ' + position);\n        }\n        state.position = [position[0], position[1]];\n        return context;\n    }\n\n    /**\n     * Walk in a given direction based on the current position.\n     *\n     * @memberOf gridl\n     * @method\n     * @instance\n     *\n     * @param {Array} direction - The direction you want to go. (It's the position relative to the current position)\n     * @returns {gridl} The same gridl instance.\n     */\n    function walk(direction) {\n        var position = state.position;\n\n        if (!(0, _utils.isValidPositionFormat)(direction)) {\n            throw new Error('Trying to walk into an invalid direction. Given: ' + direction);\n        }\n        state.position = (0, _utils.addPositions)(position, direction);\n        return context;\n    }\n\n    return {\n        methods: {\n            goto: goto,\n            position: position,\n            walk: walk\n        }\n    };\n};\n\nvar _index = __webpack_require__(1);\n\nvar _index2 = _interopRequireDefault(_index);\n\nvar _utils = __webpack_require__(0);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nmodule.exports = exports['default'];\n\n/***/ }),\n/* 14 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nexports.default = function (context, state) {\n\n    /**\n     * Rotate the array in a 90 degree steps. A positive step turns it clockwise, a negative step turns it counterclockwise.\n     *\n     * @memberOf gridl\n     * @method\n     * @instance\n     *\n     * @param {number} steps - The number of 90 degree turns as integer number.\n     * @returns {gridl} The same gridl instance.\n     */\n    function rotate(steps) {\n        var data = state.data,\n            columns = state.columns;\n\n        var grid = _rotate((0, _utils.unflatten)(data, columns), columns, steps);\n        state.data = (0, _utils.flatten)(grid);\n        state.rows = grid.length;\n        state.columns = grid[0].length;\n        return context;\n    }\n\n    return { methods: { rotate: rotate } };\n};\n\nvar _utils = __webpack_require__(0);\n\nfunction _rotate(grid, columns, steps) {\n    var mod = steps % 4;\n    var option = mod < 0 ? mod + 4 : mod;\n    switch (option) {\n        case 0:\n            return grid;\n        case 1:\n            return Array.from({ length: columns }, function (v, i) {\n                return (0, _utils.getColumn)(grid, i).reverse();\n            });\n        case 2:\n            return grid.reverse().map(function (row, r) {\n                return row.reverse();\n            });\n        case 3:\n            return Array.from({ length: columns }, function (v, i) {\n                return (0, _utils.getColumn)(grid, columns - 1 - i);\n            });\n        default:\n            throw new Error('Trying to rotate the grid with an invalid steps parameter. Given: ' + steps);\n    }\n}\n\nmodule.exports = exports['default'];\n\n/***/ }),\n/* 15 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nexports.default = function (context, state) {\n\n    /**\n     * Get the number of rows.\n     *\n     * @memberOf gridl\n     * @method\n     * @instance\n     * @returns {number}\n     */\n    function numRows() {\n        return state.rows;\n    }\n\n    /**\n     * Get the row at a certain y-position.\n     *\n     * @memberOf gridl\n     * @method\n     * @instance\n     *\n     * @param {number} y - The y-position of the row you want to get.\n     * @returns {Array.<*>}\n     */\n    function row(y) {\n        var data = state.data,\n            columns = state.columns;\n\n        return getRow((0, _utils.unflatten)(data, columns), y);\n    }\n\n    /**\n     * Add a row at a certain y-position. This changes the size of the grid.\n     *\n     * @memberOf gridl\n     * @method\n     * @instance\n     *\n     * @param {Array.<*>} row - The row you want to add as an one-dimensional array.\n     * @param {number} y - The y-position of where you want to add the row.\n     * @returns {gridl} The same gridl instance.\n     */\n    function addRow(row, y) {\n        var data = state.data,\n            rows = state.rows,\n            columns = state.columns;\n\n        if (y < 0 || y > rows) {\n            throw new Error('Trying to add row at an invalid position. Given: ' + y);\n        }\n        if (row.length !== columns) {\n            throw new Error('Trying to add a row that contains an invalid amount of cells. Expected: ' + columns + ', Given: ' + row.length);\n        }\n        var grid = (0, _utils.unflatten)(data, columns);\n        grid.splice(y, 0, row);\n        state.data = (0, _utils.flatten)(grid);\n        state.rows = grid.length;\n        return context;\n    }\n\n    /**\n     * Remove a row at a certain y-position. This changes the size of the grid.\n     *\n     * @memberOf gridl\n     * @method\n     * @instance\n     *\n     * @param {number} y - The y-position of the row you want to remove.\n     * @returns {gridl} The same gridl instance.\n     */\n    function removeRow(y) {\n        var data = state.data,\n            rows = state.rows,\n            columns = state.columns;\n\n        if (y < 0 || y >= rows) {\n            throw new Error('Trying to remove a row at an invalid position. Given: ' + y);\n        }\n        if (rows <= 1) {\n            throw new Error('Cannot remove row because the grid would be empty after it.');\n        }\n        var grid = (0, _utils.unflatten)(data, columns);\n        grid.splice(y, 1);\n        state.data = (0, _utils.flatten)(grid);\n        state.rows = grid.length;\n        return context;\n    }\n\n    return {\n        methods: {\n            addRow: addRow,\n            numRows: numRows,\n            removeRow: removeRow,\n            row: row\n        }\n    };\n};\n\nvar _index = __webpack_require__(1);\n\nvar _index2 = _interopRequireDefault(_index);\n\nvar _utils = __webpack_require__(0);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar getRow = function getRow(data, y) {\n    return data[y];\n};\n\nmodule.exports = exports['default'];\n\n/***/ }),\n/* 16 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nexports.default = function (context, state) {\n\n    /**\n     * Get the current size of the grid.\n     *\n     * @memberOf gridl\n     * @method\n     * @instance\n     *\n     * @returns {number[]}\n     */\n    function size() {\n        var columns = state.columns,\n            rows = state.rows;\n\n        return [columns, rows];\n    }\n\n    /**\n     * Exports a copy of the internal data as two-dimensional array or imports a new data into the array. If you use it to import new grid data, make sure the new data has the same size.\n     *\n     * @memberOf gridl\n     * @method\n     * @instance\n     *\n     * @param {Array.<Array.<*>>} [newData] The new data you want to import as a two-dimensional grid array.\n     * @returns {Array.<Array.<*>>} The data as two-dimensional array or the same gridl instance if you use it as a setter.\n     */\n    function data(newData) {\n        if (arguments.length) {\n            (0, _utils.validateGridArray)(newData);\n            state.data = (0, _utils.flatten)(newData);\n            return context;\n        }\n        return (0, _utils.unflatten)(state.data, state.columns);\n    }\n\n    /**\n     * Exports all entries as an one dimensional array.\n     *\n     * @memberOf gridl\n     * @method\n     * @instance\n     *\n     * @returns {Array.<*>}\n     */\n    function list() {\n        return [].concat(_toConsumableArray(state.data));\n    }\n\n    /**\n     * Make a clone of the current gridl instance.\n     *\n     * @memberOf gridl\n     * @method\n     * @instance\n     *\n     * @returns {gridl} A new gridl instance.\n     */\n    function clone() {\n        var data = state.data,\n            columns = state.columns,\n            position = state.position;\n\n        return (0, _index2.default)((0, _utils.unflatten)(data, columns)).goto(position);\n    }\n\n    return {\n        methods: {\n            size: size,\n            data: data,\n            list: list,\n            clone: clone\n        }\n    };\n};\n\nvar _index = __webpack_require__(1);\n\nvar _index2 = _interopRequireDefault(_index);\n\nvar _utils = __webpack_require__(0);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\nmodule.exports = exports['default'];\n\n/***/ }),\n/* 17 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nexports.default = function (context, state) {\n\n    /**\n     * Swaps the values of the cell at the current position and another cell.<br>\n     * The current position can be defined by [goto(position)]{@link gridl#goto} or [walk(direction)]{@link gridl#walk}.\n     *\n     * @memberOf gridl\n     * @method\n     * @instance\n     *\n     * @param {Array.<number>} otherPosition - The position of the first cell.\n     * @returns {gridl} The same gridl instance.\n     */\n    function swapCell(otherPosition) {\n        var data = state.data,\n            columns = state.columns,\n            rows = state.rows,\n            position = state.position;\n\n        _swapCells(data, columns, rows, position, otherPosition);\n        return context;\n    }\n\n    /**\n     * Swaps the values of two cells.\n     *\n     * @memberOf gridl\n     * @method\n     * @instance\n     *\n     * @param {Array.<number>} position1 - The position of the first cell.\n     * @param {Array.<number>} position2 - The position of the second cell.\n     * @returns {gridl} The same gridl instance.\n     */\n    function swapCells(position1, position2) {\n        var data = state.data,\n            columns = state.columns,\n            rows = state.rows;\n\n        _swapCells(data, columns, rows, position1, position2);\n        return context;\n    }\n\n    /**\n     * Swaps the values of two columns.\n     *\n     * @memberOf gridl\n     * @method\n     * @instance\n     *\n     * @param {Array.<number>} x1 - The x-position of the first column.\n     * @param {Array.<number>} x2 - The x-position of the second column.\n     * @returns {gridl} The same gridl instance.\n     */\n    function swapColumns(x1, x2) {\n        var data = state.data,\n            columns = state.columns;\n\n        if (x1 < 0 || x1 >= columns) {\n            throw new Error('Trying to swap columns from an invalid position. Given: ' + x1);\n        }\n        if (x2 < 0 || x2 >= columns) {\n            throw new Error('Trying to swap columns to an invalid position. Given: ' + x2);\n        }\n        var grid = (0, _utils.unflatten)(data, columns).map(function (row) {\n            _swap(row, x1, x2);\n            return row;\n        });\n        state.data = (0, _utils.flatten)(grid);\n        return context;\n    }\n\n    /**\n     * Swaps the values of two rows.\n     *\n     * @memberOf gridl\n     * @method\n     * @instance\n     *\n     * @param {Array.<number>} y1 - The y-position of the first row.\n     * @param {Array.<number>} y2 - The y-position of the second row.\n     * @returns {gridl} The same gridl instance.\n     */\n    function swapRows(y1, y2) {\n        var data = state.data,\n            columns = state.columns,\n            rows = state.rows;\n\n        if (y1 < 0 || y1 >= rows) {\n            throw new Error('Trying to swap rows from an invalid position. Given: ' + y1);\n        }\n        if (y2 < 0 || y2 >= rows) {\n            throw new Error('Trying to swap rows to an invalid position. Given: ' + y2);\n        }\n        state.data = (0, _utils.flatten)(_swap((0, _utils.unflatten)(data, columns), y1, y2));\n        return context;\n    }\n\n    return {\n        methods: {\n            swapCell: swapCell,\n            swapCells: swapCells,\n            swapColumns: swapColumns,\n            swapRows: swapRows\n        }\n    };\n};\n\nvar _utils = __webpack_require__(0);\n\nvar _swap = function _swap(arr, i1, i2) {\n    var tmp = arr[i1];\n    arr[i1] = arr[i2];\n    arr[i2] = tmp;\n    return arr;\n};\n\nvar _swapCells = function _swapCells(data, columns, rows, position1, position2) {\n    var size = [columns, rows];\n    if ((0, _utils.isNotInArea)(size, position1) || (0, _utils.isNotInArea)(size, position2)) {\n        throw new Error('Trying to swap cells with an invalid position.');\n    }\n    var index1 = (0, _utils.pos2index)(position1, columns);\n    var index2 = (0, _utils.pos2index)(position2, columns);\n    return _swap(data, index1, index2);\n};\n\nmodule.exports = exports['default'];\n\n/***/ }),\n/* 18 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nexports.default = function (context, state) {\n\n    /**\n     * Get or set the value at the current position.<br>\n     * It returns the cell's value if you provide no value and sets it if you do provide a value.\n     *\n     * @memberOf gridl\n     * @method\n     * @instance\n     *\n     * @param {*} [value] - The value you want to set or <code>undefined</code> if you want to get the value.\n     * @returns {*} The cell's value or the gridl instance if you use it as a setter.\n     */\n    function value(value) {\n        var data = state.data,\n            columns = state.columns,\n            rows = state.rows,\n            position = state.position;\n\n        if (arguments.length < 1) {\n            return (0, _utils.getValueAt)(data, columns, position);\n        }\n        (0, _utils.setValueAt)(data, columns, rows, position, value);\n        return context;\n    }\n\n    /**\n     * Get or set the value at a certain position.<br>\n     * It returns the cell's value if you provide no value and sets it if you do provide a value.\n     *\n     * @memberOf gridl\n     * @method\n     * @instance\n     *\n     * @param {Array.<number>} pos - The position where you want to set or get the value.\n     * @param {*} [value] - The value you want to set or <code>undefined</code> if you want to get the value.\n     * @returns {*} The cell's value or the the same gridl instance if you use it as a setter.\n     */\n    function valueAt(pos, value) {\n        var data = state.data,\n            columns = state.columns,\n            rows = state.rows;\n\n        if (arguments.length < 2) {\n            return (0, _utils.getValueAt)(data, columns, pos);\n        }\n        (0, _utils.setValueAt)(data, columns, rows, pos, value);\n        return context;\n    }\n\n    return { methods: { value: value, valueAt: valueAt } };\n};\n\nvar _utils = __webpack_require__(0);\n\nmodule.exports = exports['default'];\n\n/***/ }),\n/* 19 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _directions = __webpack_require__(2);\n\nvar _directions2 = _interopRequireDefault(_directions);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * Predefined lists of adjacent positions relative to a certain position.\n *\n * @namespace\n *\n * @type {Object}\n * @property {number[][]} ALL - all direct adjacent positions (orthogonal + diagonal) in the order: left to right, top to bottom\n * @property {number[][]} ALL_CW - all direct adjacent positions (orthogonal + diagonal) in clockwise order\n * @property {number[][]} ALL_CCW - all direct adjacent positions (orthogonal + diagonal) in counterclockwise order\n * @property {number[][]} ORTHOGONAL - all orthogonal adjacent positions in the order: left to right, top to bottom\n * @property {number[][]} ORTHOGONAL_CW - all orthogonal adjacent positions in clockwise order\n * @property {number[][]} ORTHOGONAL_CCW - all orthogonal adjacent positions in counterclockwise order\n * @property {number[][]} DIAGONAL - all diagonal adjacent positions in the order: left to right, top to bottom\n * @property {number[][]} DIAGONAL_CW - all diagonal adjacent positions in clockwise order\n * @property {number[][]} DIAGONAL_CCW - all diagonal adjacent positions in counterclockwise order\n */\nvar adjacences = Object.freeze({\n    ALL: Object.freeze([_directions2.default.UP_LEFT, _directions2.default.UP, _directions2.default.UP_RIGHT, _directions2.default.LEFT, _directions2.default.RIGHT, _directions2.default.DOWN_LEFT, _directions2.default.DOWN, _directions2.default.DOWN_RIGHT]),\n    ALL_CW: Object.freeze([_directions2.default.UP, _directions2.default.UP_RIGHT, _directions2.default.RIGHT, _directions2.default.DOWN_RIGHT, _directions2.default.DOWN, _directions2.default.DOWN_LEFT, _directions2.default.LEFT, _directions2.default.UP_LEFT]),\n    ALL_CCW: Object.freeze([_directions2.default.UP, _directions2.default.UP_LEFT, _directions2.default.LEFT, _directions2.default.DOWN_LEFT, _directions2.default.DOWN, _directions2.default.DOWN_RIGHT, _directions2.default.RIGHT, _directions2.default.UP_RIGHT]),\n    ORTHOGONAL: Object.freeze([_directions2.default.UP, _directions2.default.LEFT, _directions2.default.RIGHT, _directions2.default.DOWN]),\n    ORTHOGONAL_CW: Object.freeze([_directions2.default.UP, _directions2.default.RIGHT, _directions2.default.DOWN, _directions2.default.LEFT]),\n    ORTHOGONAL_CCW: Object.freeze([_directions2.default.UP, _directions2.default.LEFT, _directions2.default.DOWN, _directions2.default.RIGHT]),\n    DIAGONAL: Object.freeze([_directions2.default.UP_LEFT, _directions2.default.UP_RIGHT, _directions2.default.DOWN_LEFT, _directions2.default.DOWN_RIGHT]),\n    DIAGONAL_CW: Object.freeze([_directions2.default.UP_RIGHT, _directions2.default.DOWN_RIGHT, _directions2.default.DOWN_LEFT, _directions2.default.UP_LEFT]),\n    DIAGONAL_CCW: Object.freeze([_directions2.default.UP_LEFT, _directions2.default.DOWN_LEFT, _directions2.default.DOWN_RIGHT, _directions2.default.UP_RIGHT])\n});\n\nexports.default = adjacences;\nmodule.exports = exports['default'];\n\n/***/ })\n/******/ ]);\n});\n\n\n// WEBPACK FOOTER //\n// gridl.min.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 1);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 99dc703721a26c5bef17","/**\n * Calculates the position according to an index.\n *\n * @memberOf utils\n * @method\n *\n * @param {number} index - The index on a one-dimensional list array.\n * @param {number} columns - The number of columns of the two-dimensional grid array.\n * @returns {number[]} The position according to the index.\n */\nexport const index2pos = (index, columns) => [index % columns, Math.floor(index / columns)];\n\n/**\n * Calculates the index according to the position.\n *\n * @memberOf utils\n * @method\n *\n * @param {number[]} position - The position on a two-dimensional array.\n * @param {number} columns - The number of columns of the two-dimensional array.\n * @returns {number} The index according to the position.\n */\nexport const pos2index = (position, columns) => position && position[0] + position[1] * columns;\n\n/**\n * Converts a two-dimensional grid array into a one-dimensional list array.\n *\n * @memberOf utils\n * @method\n *\n * @param {number[][]} array2D - The two-dimensional array that should be converted.\n * @returns {number[]} A one-dimensional array.\n */\nexport const flatten = array2D => array2D.reduce((res, row) => [...res, ...row], []);\n\n/**\n * Converts a one-dimensional list array into a two dimensional grid array.\n *\n * @memberOf utils\n * @method\n *\n * @param {number[]} array1D - The one-dimensional array you want to convert.\n * @param {number} columns - The number of columns the new two-dimensional array should have.\n * @returns {number[][]} - A two-dimensional array.\n */\nexport const unflatten = (array1D, columns) => array1D.reduce((res, cell, index) => {\n    const pos = index2pos(index, columns);\n    if (!res[pos[1]]) {\n        res[pos[1]] = [];\n    }\n    res[pos[1]][pos[0]] = cell;\n    return res;\n}, []);\n\n/**\n * Adds the x and y values of two positions.\n *\n * @memberOf utils\n * @method\n *\n * @param {number[]} p1 - The first position.\n * @param {number[]} p2 - The second position.\n * @returns {number[]} The sum of both positions.\n */\nexport const addPositions = (p1, p2) => [\n    p1[0] + p2[0],\n    p1[1] + p2[1],\n];\n\n/**\n * Subtracts the x and y value of two positions.\n *\n * @memberOf utils\n * @method\n *\n * @param {number[]} p1 - The first position.\n * @param {number[]} p2 - The second position.\n * @returns {number[]} - The difference of both positions.\n */\nexport const subtractPositions = (p1, p2) => [\n    p1[0] - p2[0],\n    p1[1] - p2[1],\n];\n\n/**\n * Limits a value to be between a minimum and maximum value.\n *\n * @memberOf utils\n * @method\n *\n * @param {number} value - The value that should be limited.\n * @param {number} min - The minimum value.\n * @param {number} max - The maximum value.\n * @returns {number} The limited value.\n */\nexport const limit = (value, min, max) => Math.max(Math.min(value, max), min);\n\n/**\n * Determines if a position is located within in an area.\n *\n * @memberOf utils\n * @method\n *\n * @param {number[]} areaSize - The size of the area.\n * @param {number[]} position - The position.\n * @returns {boolean} Whether or not the position is located within the area.\n */\nexport const isNotInArea = (areaSize, position) => (\n    position[0] < 0 || position[0] >= areaSize[0] ||\n    position[1] < 0 || position[1] >= areaSize[1]\n);\n\n/**\n * Get a value at a given position. This method is operating on a one-dimensional array.\n *\n * @memberOf utils\n * @method\n *\n * @param {Array.<*>} data - The one-dimensional source array.\n * @param {number} columns - The number of columns.\n * @param {number[]} pos - The position where to get the value\n * @returns {*} - The value at the given position.\n */\nexport const getValueAt = (data, columns, pos) => {\n    const index = pos2index(pos, columns);\n    if (isNaN(index)) {\n        return;\n    }\n    return data[index];\n};\n\n/**\n * Set the value at a given position. This method is operating on a one-dimensional array.\n *\n * @memberOf utils\n * @method\n *\n * @param {Array.<*>} data - The one-dimensional source array.\n * @param {number} columns - The number of columns.\n * @param {number} rows - The number of rows.\n * @param {number[]} pos - The position where to set the value.\n * @param {*} value - The value to set.\n * @returns {boolean} - Whether or not the value was set successfully.\n */\nexport const setValueAt = (data, columns, rows, pos, value) => {\n    if (isNotInArea([columns, rows], pos)) {\n        return false;\n    }\n    const index = pos2index(pos, columns);\n    if (!isNaN(index)) {\n        data[index] = value;\n    }\n    return true;\n};\n\n/**\n * Extracts a column at a given x position. This method operates on a one-dimensional grid array.\n *\n * @memberOf utils\n * @method\n *\n * @param {Array.<*>} data - The one-dimensional source array.\n * @param {number} x - The x position of the column.\n * @returns {Array.<*>} - The column.\n */\nexport const getColumn = (data, x) => {\n    if (x >= 0 && x < data[0].length) {\n        return data.map(row => row[x]);\n    }\n};\n\n/**\n * Check if the position is in a valid format.\n *\n * @memberOf utils\n * @method\n *\n * @param {Array.<number>} position - The position to validate.\n * @returns {boolean} Whether or not it has a valid position format.\n */\nexport const isValidPositionFormat = position => {\n    if (!Array.isArray(position) || position.length !== 2) {\n        return false;\n    }\n    return (Number.isSafeInteger(position[0]) && Number.isSafeInteger(position[1]));\n};\n\n/**\n * Checks if the given data is a valid two-dimensional grid array.\n *\n * @memberOf utils\n * @method\n *\n * @param {Array.<Array.<*>>} data - The data to validate.\n */\nexport const validateGridArray = data => {\n    if (!Array.isArray(data)) {\n        throw new Error('Trying to import data that is not an array.');\n    }\n    data.forEach((row, i) => {\n        if (!Array.isArray(row)) {\n            throw new Error('Trying to import data that is not an array.');\n        }\n        if (i > 0 && data[i - 1].length !== row.length) {\n            throw new Error('Trying to import data with inconsistent number of columns.');\n        }\n        if (row.length < 1) {\n            throw new Error('Trying to import grid without any columns. You need to provide at least one column.');\n        }\n    });\n};\n\n/**\n * Utility functions. These methods are useful when working with gridl's internal data. You could find them helpful when\n * developing your own plugins.\n *\n * @namespace\n * @type {Object}\n */\nconst utils = {\n    flatten,\n    isValidPositionFormat,\n    unflatten,\n    index2pos,\n    pos2index,\n    addPositions,\n    subtractPositions,\n    limit,\n    isNotInArea,\n    getColumn,\n    getValueAt,\n    setValueAt,\n    validateGridArray,\n};\n\nexport default utils;\n\n\n// WEBPACK FOOTER //\n// ./src/utils.js","import utils from './utils';\nimport generators from './generators';\nimport plugins from './plugins';\nimport directions from './directions';\nimport adjacences from './adjacences';\n\nconst { flatten, validateGridArray } = utils;\n\nfunction registerPlugins(plugins, state) {\n    Object.entries(plugins).forEach(([key, pluginFactory]) => {\n        const plugin = pluginFactory(this, state);\n        const type = typeof plugin;\n\n        // plugin is just a function\n        if (type === 'function') {\n            this[key] = plugin;\n        }\n\n        // plugin returns multiple functions with a namespace\n        else if (type === 'object' && plugin.methods && plugin.namespace) {\n            this[key] = plugin.methods;\n        }\n\n        // plugin returns multiple functions without a namespace\n        else if (type === 'object' && plugin.methods) {\n            Object.entries(plugin.methods).forEach(([k, func]) => {\n                this[k] = func;\n            });\n        }\n    });\n}\n\n/**\n * @class\n * @private\n */\nfunction gridl(plugins, data) {\n\n    // validate incoming data\n    validateGridArray(data);\n\n    // create initial state\n    const initialState = {\n        rows: data.length,\n        columns: data[0].length,\n        data: flatten(data),\n        position: [0,0],\n    };\n\n    // register plugins with initial state\n    registerPlugins.call(this, plugins, initialState);\n\n    return this;\n}\n\n/**\n * Creates a new gridl instance.\n *\n * @constructs gridl\n * @param {Array.<Array.<*>>} data - A two dimensional grid array. Every row needs to have the same length.\n */\nconst gridlFactory = data => new gridl(plugins, data);\ngridlFactory.fn = plugins;\n\nexport { utils, generators, adjacences, directions };\n\nexport default gridlFactory;\n\n\n\n// WEBPACK FOOTER //\n// ./src/index.js","/**\n * Predefined directions you can walk in.<br>\n * Use it in combination with [walk(direction)]{@link gridl#walk}.\n *\n * @namespace\n *\n * @type {Object}\n * @property {Array.<number>} UP - one step up\n * @property {Array.<number>} UP_LEFT - one step left, one step up\n * @property {Array.<number>} UP_RIGHT - one step right, one step up\n * @property {Array.<number>} RIGHT - one step right\n * @property {Array.<number>} LEFT - one step left\n * @property {Array.<number>} DOWN - one step down\n * @property {Array.<number>} DOWN_LEFT - one step left, one step down\n * @property {Array.<number>} DOWN_RIGHT - one step right, one step down\n */\nconst directions = Object.freeze({\n    UP:         Object.freeze([ 0, -1]),\n    UP_RIGHT:   Object.freeze([ 1, -1]),\n    RIGHT:      Object.freeze([ 1,  0]),\n    DOWN_RIGHT: Object.freeze([ 1,  1]),\n    DOWN:       Object.freeze([ 0,  1]),\n    DOWN_LEFT:  Object.freeze([-1,  1]),\n    LEFT:       Object.freeze([-1,  0]),\n    UP_LEFT:    Object.freeze([-1, -1]),\n});\n\nexport default directions;\n\n\n\n// WEBPACK FOOTER //\n// ./src/directions.js","import gridl from './index';\n\n/**\n * Create a two dimensional grid array.\n *\n * @memberOf generators\n * @param {number} columns - The number of columns.\n * @param {number} rows - The number of rows.\n * @param {Function} callback - The generator function that is called on each cell.\n * @returns {Array.<Array.<*>>} The new grid array.\n */\nexport function makeDataGrid(columns, rows, callback = () => null) {\n    const parsedColumns = parseInt(columns);\n    const parsedRows = parseInt(rows);\n    if (parsedColumns < 1 || isNaN(parsedColumns)) {\n        throw new Error(`You need to specify at least one column. Given: ${columns}`);\n    }\n    if (parsedRows < 1 || isNaN(parsedRows)) {\n        throw new Error(`You need to specify at least one row. Given: ${rows}`);\n    }\n    return Array.from({ length: parsedRows }, (vr, row) => (\n        Array.from({ length: parsedColumns }, (vc, column) => (\n            callback({ column, row })\n        ))\n    ));\n}\n\n/**\n * Generate a one-dimensional array that can be a single row or column.\n *\n * @memberOf generators\n * @param {number} length - The length of the array.\n * @param {Function} callback - The generator callback function that is called on each element.\n * @returns {Array.<*>}\n */\nexport function makeDataList(length, callback = () => null) {\n    const parsedLength = parseInt(length);\n    if (parsedLength < 1 || isNaN(parsedLength)) {\n        throw new Error(`Trying to make a list with an invalid length. Given: ${length}`);\n    }\n    return Array.from({ length: parsedLength }, (v, i) => callback(i));\n}\n\n/**\n * Generate a gridl instance from scratch by specifying the number of rows and columns and fill it with values.\n *\n * @memberOf generators\n * @param {number} numColumns - The number of columns.\n * @param {number} numRows - The number of rows.\n * @param {Function} callback - The generator function that is called for each cell. The returned value is going to be the value of the cell.\n * @returns {gridl} A new gridl instance\n */\nexport function makeGridl(numColumns, numRows, callback) {\n    return gridl(makeDataGrid(numColumns, numRows, callback));\n}\n\n/**\n * @namespace generators\n */\nexport default {\n    makeGridl,\n    makeDataGrid,\n    makeDataList,\n}\n\n\n// WEBPACK FOOTER //\n// ./src/generators.js","import adjacence from './adjacence';\nimport area from './area';\nimport clipping from './clipping';\nimport columns from './columns';\nimport finding from './finding';\nimport flip from './flip';\nimport iterator from './iterator';\nimport moving from './moving';\nimport navigating from './navigating';\nimport rotating from './rotating';\nimport rows from './rows';\nimport state from './state';\nimport swapping from './swapping';\nimport value from './value';\n\nexport default {\n    adjacence,\n    area,\n    clipping,\n    columns,\n    finding,\n    flip,\n    iterator,\n    moving,\n    navigating,\n    rotating,\n    rows,\n    state,\n    swapping,\n    value,\n};\n\n\n\n// WEBPACK FOOTER //\n// ./src/plugins/index.js","import gridl, {adjacences} from '../index';\nimport { unflatten, addPositions, isNotInArea } from '../utils';\n\nconst _adjacentCells = (grid, position, adjacence, gridSize = null) => {\n    return adjacence.reduce((res, direction) => {\n        const absPos = addPositions(position, direction);\n        const value = grid && grid[absPos[1]] && grid[absPos[1]][absPos[0]];\n        if (gridSize) {\n            return isNotInArea(gridSize, absPos) ? res : [...res, value];\n        }\n        else {\n            return [...res, value];\n        }\n    }, []);\n};\n\nexport default function(context, state) {\n\n    /**\n     * Get the values of all adjacent cells at a given position.\n     *\n     * @memberOf gridl\n     * @method\n     * @instance\n     *\n     * @param {number[]} position - The position of the cell of which you want to know its adjacent cells.\n     * @param {number[][]} [adjacence = [adjacents.ALL]{@link adjacences}] - A list of positions relative to the given position. These positions are considered as the adjacents.\n     * @param {boolean} [includeOutsideValues = false] - If <code>false</code>, adjacent cells that are outside the grid will be ignored, if <code>true</code>, <code>undefined</code> will be returned for them.\n     * @returns {Array.<*>} The values of the adjacent cells.\n     */\n    function adjacentCellsAt(position, adjacence = adjacences.ALL, includeOutsideValues = false) {\n        const { data, columns, rows } = state;\n        const gridSize = !includeOutsideValues && [columns, rows];\n        const grid = unflatten(data, columns);\n        return _adjacentCells(grid, position, adjacence, gridSize);\n    }\n\n    /**\n     * Get the values of all adjacent cells at the current position.<br>\n     * The current position can be defined by [goto(position)]{@link gridl#goto} or [walk(direction)]{@link gridl#walk}.\n     *\n     * @memberOf gridl\n     * @method\n     * @instance\n     *\n     * @param {number[][]} [adjacence = [adjacents.ALL]{@link adjacences}] - A list of positions relative to the given position. These positions are considered as the adjacents.\n     * @param {boolean} [includeOutsideValues = false] - If <code>false</code>, adjacent cells that are outside the grid will be ignored, if <code>true</code>, <code>undefined</code> will be returned for them.\n     * @returns {Array.<*>} The values of the adjacent cells.\n     */\n    function adjacentCells(adjacence = adjacences.ALL, includeOutsideValues = false) {\n        const { data, columns, rows, position } = state;\n        const gridSize = !includeOutsideValues && [columns, rows];\n        const grid = unflatten(data, columns);\n        return _adjacentCells(grid, position, adjacence, gridSize);\n    }\n\n    return {\n        methods: {\n            adjacentCells,\n            adjacentCellsAt,\n        }\n    };\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/plugins/adjacence.js","import gridl from '../index';\nimport {\n    setValueAt,\n    subtractPositions,\n    index2pos,\n    flatten,\n    addPositions,\n    isValidPositionFormat, getValueAt,\n} from '../utils';\n\nconst _getAreaAt = (data, columns, rows, position, size, anchor = [0,0]) => {\n    const posTmp = subtractPositions(position, anchor);\n    const end = [\n        Math.min(posTmp[0] + size[0], columns),\n        Math.min(posTmp[1] + size[1], rows),\n    ];\n    const pos = [\n        Math.max(0, posTmp[0]),\n        Math.max(0, posTmp[1]),\n    ];\n    const area = [];\n    for (let r = pos[1]; r < end[1]; r++) {\n        const rArea = r - pos[1];\n        if (!area[rArea]) {\n            area[rArea] = [];\n        }\n        for (let c = pos[0]; c < end[0]; c++) {\n            const cArea = c - pos[0];\n            area[rArea][cArea] = getValueAt(data, columns, [c, r]);\n        }\n    }\n    return area;\n};\n\nconst _checkAreaFitsAt = (columns, rows, position, area, anchor = [0,0]) => {\n    const pos = subtractPositions(position, anchor);\n    const fitsHorizontally = pos[0] >= 0 && pos[0] + area[0].length <= columns;\n    const fitsVertically = pos[1] >= 0 && pos[1] + area.length <= rows;\n    return fitsHorizontally && fitsVertically;\n};\n\nconst _setAreaAt = (data, columns, rows, position, area, anchor = [0,0]) => {\n    const pos = subtractPositions(position, anchor);\n    area.forEach((row, r) => {\n        const targetPos = [0, r + pos[1]];\n        if (targetPos[1] >= rows) {\n            return;\n        }\n        row.forEach((cell, c) => {\n            targetPos[0] = c + pos[0];\n            if (targetPos[0] >= columns) {\n                return;\n            }\n            setValueAt(data, columns, rows, targetPos, cell);\n        });\n    });\n    return data;\n};\n\nconst _reduceAreaAt = (api, data, columns, rows, position, size, callback, initialValue, hasInitialValue) => {\n    if (!isValidPositionFormat(position)) {\n        throw new Error('Trying to reduce an area at an invalid position.');\n    }\n    if (!isValidPositionFormat(size)) {\n        throw new Error('Trying to reduce an area with invalid size.');\n    }\n    const reducer = (acc, v, i) => {\n        const local = index2pos(i, size[0]);\n        const global = addPositions(local, position);\n        return callback(acc, v, global, api);\n    };\n    const flattenedArea = flatten(_getAreaAt(data, columns, rows, position, size));\n    return hasInitialValue ? flattenedArea.reduce(reducer) : flattenedArea.reduce(reducer, initialValue);\n};\n\nexport default function(context, state) {\n\n    /**\n     * Check if a given area would fit inside the grid at the current position.<br>\n     * The current position can be defined by [goto(position)]{@link gridl#goto} or [walk(direction)]{@link gridl#walk}.\n     *\n     * @memberOf gridl\n     * @method\n     * @instance\n     *\n     * @param {Array.<Array.<*>>} area - The area itself as a two-dimensional grid array\n     * @param {number[]} [anchor = [0, 0]] - The center of area.\n     * @returns {boolean} Whether the area fits or not.\n     */\n    function areaFits(area, anchor) {\n        const { columns, rows, position } = state;\n        return _checkAreaFitsAt(columns, rows, position, area, anchor);\n    }\n\n    /**\n     * Check if a given area would fit inside the grid at a given position.\n     *\n     * @memberOf gridl\n     * @method\n     * @instance\n     *\n     * @param {number[]} position - The position where the area should be placed.\n     * @param {Array.<Array.<*>>} area - The area itself as a two-dimensional grid array\n     * @param {number[]} [anchor = [0, 0]] - The center of area.\n     * @returns {boolean} Whether the area fits or not.\n     */\n    function areaFitsAt(position, area, anchor) {\n        const { columns, rows } = state;\n        return _checkAreaFitsAt(columns, rows, position, area, anchor);\n    }\n\n    /**\n     * Exports the data grid array of a given array at the current position.<br>\n     * The current position can be defined by [goto(position)]{@link gridl#goto} or [walk(direction)]{@link gridl#walk}.\n     *\n     * @memberOf gridl\n     * @method\n     * @instance\n     *\n     * @param {Array.<number>} size - The size fo the area as a two-dimensional grid array.\n     * @param {Array.<number>} [anchor = [0, 0]] - The center of area.\n     * @returns {Array.<Array.<*>>} The area.\n     */\n    function getArea(size, anchor) {\n        const { data, columns, rows, position } = state;\n        return _getAreaAt(data, columns, rows, position, size, anchor);\n    }\n\n    /**\n     * Exports the data grid array of a given array at the given position.\n     *\n     * @memberOf gridl\n     * @method\n     * @instance\n     *\n     * @param {Array.<number>} position - The position of the area.\n     * @param {Array.<number>} size - The size fo the area as a two-dimensional grid array.\n     * @param {Array.<number>} [anchor = [0, 0]] - The center of area.\n     * @returns {Array.<Array.<*>>} The area.\n     */\n    function getAreaAt(position, size, anchor) {\n        const { data, columns, rows } = state;\n        return _getAreaAt(data, columns, rows, position, size, anchor);\n    }\n\n    /**\n     * Overwrite the values of a given area at the current position.<br>\n     * The current position can be defined by [goto(position)]{@link gridl#goto} or [walk(direction)]{@link gridl#walk}.\n     *\n     * @memberOf gridl\n     * @method\n     * @instance\n     *\n     * @param {Array.<number>} area - The area itself as two-dimensional grid array.\n     * @param {Array.<number>} [anchor = [0, 0]] - The center of area.\n     * @returns {gridl} The same gridl instance.\n     */\n    function setArea(area, anchor) {\n        const { data, columns, rows, position } = state;\n        _setAreaAt(data, columns, rows, position, area, anchor);\n        return context;\n    }\n\n    /**\n     * Overwrite the values of a given area at a certain position.\n     *\n     * @memberOf gridl\n     * @method\n     * @instance\n     *\n     * @param {Array.<number>} position - The position of the area.\n     * @param {Array.<number>} area - The area itself as two-dimensional grid array.\n     * @param {Array.<number>} [anchor = [0, 0]] - The center of area.\n     * @returns {gridl} The same gridl instance.\n     */\n    function setAreaAt(position, area, anchor) {\n        const { data, columns, rows } = state;\n        _setAreaAt(data, columns, rows, position, area, anchor);\n        return context;\n    }\n\n    /**\n     * Find the first occurrence of an element within a certain area.\n     *\n     * @memberOf gridl\n     * @method\n     * @instance\n     *\n     * @param {Array} position - The position of the area [x, y].\n     * @param {Array} size - The size of the area [columns, rows].\n     * @param {iteratorCallback} callback - The callback function that is called on each element within the defined area. Should return true if the element is found or false if not.\n     * @returns {(Array.<number>|undefined)} The position of the first element that is found or <code>undefined</code> if nothing was found.\n     */\n    function findInArea(position, size, callback) {\n        const { data, columns, rows } = state;\n        const area = _getAreaAt(data, columns, rows, position, size);\n        const flat = flatten(area);\n        const areaIndex = flat.findIndex((v, i) => callback(v, index2pos(i, columns), context));\n        if (areaIndex < 0) {\n            return;\n        }\n        const areaColumns = area[0].length;\n        const posInArea = index2pos(areaIndex, areaColumns);\n        return [\n            position[0] + posInArea[0],\n            position[1] + posInArea[1],\n        ];\n    }\n\n    /**\n     * Applies a function against an accumulator and each element in the area at a given position to reduce it to a single value.\n     *\n     * @memberOf gridl\n     * @method\n     * @instance\n     *\n     * @param {number[][]} position - The position of the area within the grid.\n     * @param {number[][]} size - The size of the area within the grid.\n     * @param {reducerCallback} callback - The callback function that is executed on each cell within the grid.\n     * @param {*} [initialValue=undefined] - Value to use as the first argument to the first call of the <code>callback</code>. If no initial value is supplied, the first element in the grid will be used.\n     * @returns {*} The value that results from the reduction.\n     */\n    function reduceAreaAt(position, size, callback, initialValue) {\n        const { data, columns, rows } = state;\n        return _reduceAreaAt(context, data, columns, rows, position, size, callback, initialValue, arguments.length === 1);\n    }\n\n    /**\n     * Applies a function against an accumulator and each element in the area at the current position to reduce it to a single value.\n     *\n     * @memberOf gridl\n     * @method\n     * @instance\n     *\n     * @param {number[][]} size - The size of the area within the grid.\n     * @param {reducerCallback} callback - The callback function that is executed on each cell within the grid.\n     * @param {*} [initialValue=undefined] - Value to use as the first argument to the first call of the <code>callback</code>. If no initial value is supplied, the first element in the grid will be used.\n     * @returns {*} The value that results from the reduction.\n     */\n    function reduceArea(size, callback, initialValue) {\n        const { data, columns, rows, position } = state;\n        return _reduceAreaAt(context, data, columns, rows, position, size, callback, initialValue, arguments.length === 1);\n    }\n\n    return {\n        methods: {\n            areaFits,\n            areaFitsAt,\n            getArea,\n            getAreaAt,\n            setArea,\n            setAreaAt,\n            findInArea,\n            reduceArea,\n            reduceAreaAt,\n        },\n    };\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/plugins/area.js","import { addPositions, flatten, unflatten } from '../utils';\n\nconst _clip = (data, columns, rows, position, size) => {\n    if (position[0] < 0 || position[0] >= columns || position[1] < 0 || position[1] >= rows) {\n        throw new Error(`Trying to clip data at an invalid position. Given: ${position}`);\n    }\n    const endPoint = addPositions(position, size);\n    return unflatten(data, columns)\n        .filter((row, r) => r >= position[1] && r < endPoint[1])\n        .map(row => row.filter((cell, c) => c >= position[0] && c < endPoint[0]));\n};\n\nexport default function(context, state) {\n\n    /**\n     * Clip an area out of the current grid. It removes all cells that are not inside the given area.\n     *\n     * @memberOf gridl\n     * @method\n     * @instance\n     *\n     * @param {Array.<number>} size - The size of the area.\n     * @returns {gridl} The same gridl instance.\n     */\n    function clip(size) {\n        const { data, columns, rows, position } = state;\n        const grid = _clip(data, columns, rows, position, size);\n        state.data = flatten(grid);\n        state.rows = grid.length;\n        state.columns = grid[0].length;\n        return context;\n    }\n\n    /**\n     * Clip an area out of the current grid. It removes all cells that are not inside the given area.\n     *\n     * @memberOf gridl\n     * @method\n     * @instance\n     *\n     * @param {Array.<number>} position - The position the area.\n     * @param {Array.<number>} size - The size of the area.\n     * @returns {gridl} The same gridl instance.\n     */\n    function clipAt(position, size) {\n        const { data, columns, rows } = state;\n        const grid = _clip(data, columns, rows, position, size);\n        state.data = flatten(grid);\n        state.rows = grid.length;\n        state.columns = grid[0].length;\n        return context;\n    }\n\n    return {\n        methods: { clip, clipAt },\n    };\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/plugins/clipping.js","import gridl from '../index';\nimport { flatten, unflatten, getColumn } from '../utils';\nimport utils from '../utils';\n\nexport default function(context, state) {\n\n    /**\n     * Get the number of columns.\n     *\n     * @memberOf gridl\n     * @method\n     * @instance\n     * @returns {number}\n     */\n    function numColumns() {\n        return state.columns;\n    }\n\n    /**\n     * Get the column at a certain x-position.\n     *\n     * @memberOf gridl\n     * @method\n     * @instance\n     *\n     * @param {number} x - The x-position of the column you want to get.\n     * @returns {Array.<*>}\n     */\n    function column(x) {\n        const { data, columns } = state;\n        return getColumn(unflatten(data, columns), x);\n    }\n\n    /**\n     * Add a column at a certain x-position. This changes the size of the grid.\n     *\n     * @memberOf gridl\n     * @method\n     * @instance\n     *\n     * @param {Array.<*>} column - The column you want to add as an one-dimensional array.\n     * @param {number} x - The x-position of where you want to add the column.\n     * @returns {gridl} The same gridl instance.\n     */\n    function addColumn(column, x) {\n        const { data, columns, rows } = state;\n        if (x < 0 || x > columns) {\n            throw new Error(`Trying to add column at an invalid position. Given: ${x}`);\n        }\n        if (column.length !== rows) {\n            throw new Error(`Trying to add a column that contains an invalid amount of cells. Expected: ${rows}, Given: ${column.length}`);\n        }\n        const grid = utils.unflatten(data, columns).map((row, i) => {\n            row.splice(x, 0, column[i]);\n            return row;\n        });\n        state.data = utils.flatten(grid);\n        state.columns = grid[0].length;\n        return context;\n    }\n\n    /**\n     * Remove a column at a certain x-position. This changes the size of the grid.\n     *\n     * @memberOf gridl\n     * @method\n     * @instance\n     *\n     * @param {number} x - The x-position of the column you want to remove.\n     * @returns {gridl} The same gridl instance.\n     */\n    function removeColumn(x) {\n        const { data, columns } = state;\n        if (x < 0 || x >= columns) {\n            throw new Error(`Trying to remove a column at an invalid position. Given: ${x}`);\n        }\n        if (columns <= 1) {\n            throw new Error('Cannot remove column because the grid would be empty after it.');\n        }\n        const grid = unflatten(data, columns).map(row => row.filter((v, c) => c !== x));\n        state.data = flatten(grid);\n        state.columns = grid[0].length;\n        return context;\n    }\n\n    return {\n        methods: {\n            addColumn,\n            column,\n            numColumns,\n            removeColumn,\n        },\n    };\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/plugins/columns.js","import { index2pos } from '../utils';\n\nexport default function(context, state) {\n\n    /**\n     * Find the first occurrence of an element within the entire grid.\n     *\n     * @memberOf gridl\n     * @method\n     * @instance\n     *\n     * @param {iteratorCallback} callback - The callback function that is called on each element. Should return true if the element is found or false if not.\n     * @returns {(Array.<number>|undefined)} The position of the first element that is found or <code>undefined</code> if nothing was found.\n     */\n    function find(callback) {\n        const { data, columns } = state;\n        const index = data.findIndex((v, i) => callback(v, index2pos(i, columns), context));\n        return (index >= 0) ? index2pos(index, columns) : undefined;\n    }\n\n    return { methods: { find } };\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/plugins/finding.js","import { unflatten, flatten, limit } from '../utils';\n\nconst _flip = (arr, index) => {\n    if (index === undefined) {\n        return arr.reverse();\n    }\n    const limitedIdx = limit(index, 0, arr.length - 1);\n    const left = arr.filter((v, i) => i < limitedIdx);\n    const right = arr.filter((v, i) => i > limitedIdx);\n    return [\n        ...right.reverse(),\n        arr[limitedIdx],\n        ...left.reverse(),\n    ];\n};\n\nexport default function(context, state) {\n\n    /**\n     * Flips the array on the given x-position\n     *\n     * @param {number} xPos - The x-position of where to flip the array.\n     * @returns {gridl} The same gridl instance.\n     */\n    const flipX = (xPos) => {\n        const { data, columns } = state;\n        const grid = unflatten(data, columns);\n        state.data = flatten(_flip(grid, xPos));\n        return context;\n    };\n\n    /**\n     * Flips the array on the given y-position.\n     *\n     * @param {number} yPos - The y-position of where to flip the array.\n     * @returns {gridl} The same gridl instance.\n     */\n    function flipY(yPos) {\n        const { data, columns } = state;\n        const grid = unflatten(data, columns);\n        state.data = flatten(grid.map(row => _flip(row, yPos)));\n        return context;\n    }\n\n    return {\n        methods: { flipX, flipY },\n    };\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/plugins/flip.js","/**\n * @callback iteratorCallback\n * @param {*} cell - The value of the current cell.\n * @param {Array.<number>} position - The current position.\n * @param {gridl} gridlInstance - The current gridl instance.\n */\n\n/**\n * @callback reducerCallback\n * @param {*} accumulator - The accumulator accumulates the callback's return values; it is the accumulated value previously returned in the last invocation of the callback, or initialValue, if supplied.\n * @param {*} cell - The value of the current cell.\n * @param {Array.<number>} position - The current position.\n * @param {gridl} gridlInstance - The current gridl instance.\n */\n\nimport gridl from '../index';\nimport { index2pos, unflatten } from '../utils';\n\nexport default function(instance, state) {\n\n    /**\n     * Map over all cells. It's the equivalent of Array.map just for the grid.\n     *\n     * @memberOf gridl\n     * @method\n     * @instance\n     *\n     * @param {iteratorCallback} callback - The callback function that is called on each cell.<br><code>function(cell, position, gridlInstance) { return ... }</code>\n     * @returns {gridl} A new gridl instance.\n     */\n    function map(callback) {\n        const { data, columns } = state;\n        const newData = data.map((v, i) => callback(v, index2pos(i, columns), instance));\n        return gridl(unflatten(newData, columns));\n    }\n\n    /**\n     * Iterate over all cells. It's the equivalent of Array.forEach just for the grid.\n     *\n     * @memberOf gridl\n     * @method\n     * @instance\n     *\n     * @param {iteratorCallback} callback - The callback function is called for each cell.<br><code>function(cell, position, gridlInstance) { return ... }</code>\n     * @returns {gridl} The same gridl instance.\n     */\n    function forEach(callback) {\n        const { data, columns } = state;\n        data.forEach((v, i) => callback(v, index2pos(i, columns), instance));\n        return instance;\n    }\n\n    /**\n     * Applies a function against an accumulator and each element in the grid to reduce it to a single value.\n     *\n     * @memberOf gridl\n     * @method\n     * @instance\n     *\n     * @param {reducerCallback} callback - The callback function that is executed on each cell.<br><code>function(accumulator, cell, position, gridlInstance) { return ... }</code>\n     * @param {*} [initialValue=undefined] - Value to use as the first argument to the first call of the <code>callback</code>. If no initial value is supplied, the first element in the grid will be used.\n     * @returns {*} The value that results from the reduction.\n     */\n    function reduce(callback, initialValue) {\n        const { data, columns } = state;\n        const reducer = (acc, v, i) => callback(acc, v, index2pos(i, columns), instance);\n        return arguments.length === 1 ? data.reduce(reducer) : data.reduce(reducer, initialValue);\n    }\n\n    /**\n     * Fill every cells with a value. You can either provide a value or a callback function to set the value for each cell.\n     *\n     * @memberOf gridl\n     * @method\n     * @instance\n     *\n     * @param {(iteratorCallback|*)} callbackOrValue - Either a fixed value for each cell or a callback function to fill each cell separately.\n     * @returns {gridl} The same gridl instance.\n     */\n    function fill(callbackOrValue) {\n        const { data, columns } = state;\n        if (typeof callbackOrValue === 'function') {\n            data.forEach((v, i) => data[i] = callbackOrValue(v, index2pos(i, columns), instance));\n        }\n        else {\n            data.forEach((v, i) => data[i] = callbackOrValue);\n        }\n        return instance;\n    }\n\n    return {\n        methods: {\n            map,\n            forEach,\n            reduce,\n            fill,\n        }\n    };\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/plugins/iterator.js","import {\n    addPositions,\n    flatten,\n    isNotInArea,\n    pos2index,\n    unflatten,\n} from '../utils';\n\nconst _move = (data, fromIndex, toIndex) => {\n    const cell = data[fromIndex];\n    data.splice(fromIndex, 1);\n    data.splice(toIndex, 0, cell);\n    return data;\n};\n\nconst _moveCell = (data, columns, rows, from, to) => {\n    const fromIndex = pos2index(from, columns);\n    const size = [columns, rows];\n    if (isNaN(fromIndex) || isNotInArea(size, from)) {\n        throw new Error(`Trying to move cell from an invalid position. Given: [${from}]`);\n    }\n    const toIndex = pos2index(to, columns);\n    if (isNaN(toIndex) || isNotInArea(size, to)) {\n        throw new Error(`Trying to move cell to an invalid position. Given: [${to}]`);\n    }\n    return _move(data, fromIndex, toIndex);\n};\n\nexport default function(context, state) {\n\n    /**\n     * Move the current cell to an absolute position.\n     * The current position can be defined by [goto(position)]{@link gridl#goto} or [walk(direction)]{@link gridl#walk}.\n     *\n     * @memberOf gridl\n     * @method\n     * @instance\n     *\n     * @param {Array} to - The position where the cell should be moved.\n     * @returns {gridl}\n     */\n    function moveAbs(to) {\n        const { data, columns, rows, position } = state;\n        state.data = _moveCell(data, columns, rows, position, to);\n        return context;\n    }\n\n    /**\n     * Move a cell from one position to another.\n     *\n     * @memberOf gridl\n     * @method\n     * @instance\n     *\n     * @param {Array} from - The position of the cell that you want to move.\n     * @param {Array} to - The position where the cell should be moved.\n     * @returns {gridl} - The current gridl instance.\n     */\n    function moveCell(from, to) {\n        const { data, columns, rows } = state;\n        state.data = _moveCell(data, columns, rows, from, to);\n        return context;\n    }\n\n    /**\n     * Move a column to a certain position.\n     *\n     * @memberOf gridl\n     * @method\n     * @instance\n     *\n     * @param {number} xFrom - The position on the x-axis of the column you want to move.\n     * @param {number} xTo - The position on the x-axis of where the column should be moved.\n     * @returns {gridl}\n     */\n    function moveColumn(xFrom, xTo) {\n        const { data, columns } = state;\n        if (xFrom < 0 || xFrom >= columns) {\n            throw new Error(`Trying to move column from an invalid position. Given: ${xFrom}`);\n        }\n        if (xTo < 0 || xTo >= columns) {\n            throw new Error(`Trying to move column to an invalid position. Given: ${xTo}`);\n        }\n        state.data = flatten(unflatten(data, columns).map(row => _move(row, xFrom, xTo)));\n        return context;\n    }\n\n    /**\n     * Move the current cell from the current position in a certain direction.\n     * The current position can be defined by [goto(position)]{@link gridl#goto} or [walk(direction)]{@link gridl#walk}.\n     *\n     * @memberOf gridl\n     * @method\n     * @instance\n     *\n     * @param {Array} direction - The direction in which to move from the current position.\n     * @returns {gridl} The current gridl instance.\n     */\n    function moveRel(direction) {\n        const { data, columns, rows, position } = state;\n        state.data = _moveCell(data, columns, rows, position, addPositions(position, direction));\n        return context;\n    }\n\n    /**\n     * Move a row to a certain position.\n     *\n     * @memberOf gridl\n     * @method\n     * @instance\n     *\n     * @param {number} yFrom - The position on the y-axis of the row you want to move.\n     * @param {number} yTo - The position on the y-axis of where the row should be moved to.\n     * @returns {gridl} The current gridl instance.\n     */\n    function moveRow(yFrom, yTo) {\n        const { data, columns, rows } = state;\n        if (yFrom < 0 || yFrom >= rows) {\n            throw new Error(`Trying to move row from an invalid position. Given: ${yFrom}`);\n        }\n        if (yTo < 0 || yTo >= rows) {\n            throw new Error(`Trying to move row to an invalid position. Given: ${yTo}`);\n        }\n        state.data = flatten(_move(unflatten(data, columns), yFrom, yTo));\n        return context;\n    }\n\n    return {\n        methods: {\n            moveAbs,\n            moveCell,\n            moveColumn,\n            moveRel,\n            moveRow,\n        },\n    };\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/plugins/moving.js","import gridl from '../index';\nimport { addPositions, isValidPositionFormat } from '../utils';\n\nexport default function(context, state) {\n\n    /**\n     * Get the current position.\n     *\n     * @returns {Array} The current position array [column, row].\n     */\n    function position() {\n        const { position } = state;\n        return [\n            position[0],\n            position[1],\n        ];\n    }\n\n    /**\n     * Go to an absolute position.\n     * The internal cursor will be set to this position and can then be used for further operations.\n     *\n     * @memberOf gridl\n     * @method\n     * @instance\n     *\n     * @param {Array} position - The new position.\n     * @returns {gridl}\n     */\n    function goto(position) {\n        if (!isValidPositionFormat(position)) {\n            throw new Error(`Trying to go to an invalid position. Given: ${position}`);\n        }\n        state.position = [\n            position[0],\n            position[1],\n        ];\n        return context;\n    }\n\n    /**\n     * Walk in a given direction based on the current position.\n     *\n     * @memberOf gridl\n     * @method\n     * @instance\n     *\n     * @param {Array} direction - The direction you want to go. (It's the position relative to the current position)\n     * @returns {gridl} The same gridl instance.\n     */\n    function walk(direction) {\n        const { position } = state;\n        if (!isValidPositionFormat(direction)) {\n            throw new Error(`Trying to walk into an invalid direction. Given: ${direction}`);\n        }\n        state.position = addPositions(position, direction);\n        return context;\n    }\n\n    return {\n        methods: {\n            goto,\n            position,\n            walk,\n        },\n    };\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/plugins/navigating.js","import { getColumn, unflatten, flatten } from '../utils';\n\nfunction _rotate(grid, columns, steps) {\n    const mod = steps % 4;\n    const option = mod < 0 ? mod + 4 : mod;\n    switch (option) {\n        case 0:\n            return grid;\n        case 1:\n            return Array.from({ length: columns }, (v, i) => getColumn(grid, i).reverse());\n        case 2:\n            return grid.reverse().map((row, r) => row.reverse());\n        case 3:\n            return Array.from({ length: columns }, (v, i) => getColumn(grid, columns - 1 - i));\n        default:\n            throw new Error(`Trying to rotate the grid with an invalid steps parameter. Given: ${steps}`);\n    }\n}\n\nexport default function(context, state) {\n\n    /**\n     * Rotate the array in a 90 degree steps. A positive step turns it clockwise, a negative step turns it counterclockwise.\n     *\n     * @memberOf gridl\n     * @method\n     * @instance\n     *\n     * @param {number} steps - The number of 90 degree turns as integer number.\n     * @returns {gridl} The same gridl instance.\n     */\n    function rotate(steps) {\n        const { data, columns } = state;\n        const grid = _rotate(unflatten(data, columns), columns, steps);\n        state.data = flatten(grid);\n        state.rows = grid.length;\n        state.columns = grid[0].length;\n        return context;\n    }\n\n    return { methods: { rotate } };\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/plugins/rotating.js","import gridl from '../index';\nimport { flatten, unflatten } from '../utils';\n\nconst getRow = (data, y) => data[y];\n\nexport default function(context, state) {\n\n    /**\n     * Get the number of rows.\n     *\n     * @memberOf gridl\n     * @method\n     * @instance\n     * @returns {number}\n     */\n    function numRows() {\n        return state.rows;\n    }\n\n    /**\n     * Get the row at a certain y-position.\n     *\n     * @memberOf gridl\n     * @method\n     * @instance\n     *\n     * @param {number} y - The y-position of the row you want to get.\n     * @returns {Array.<*>}\n     */\n    function row(y) {\n        const { data, columns} = state;\n        return getRow(unflatten(data, columns), y);\n    }\n\n    /**\n     * Add a row at a certain y-position. This changes the size of the grid.\n     *\n     * @memberOf gridl\n     * @method\n     * @instance\n     *\n     * @param {Array.<*>} row - The row you want to add as an one-dimensional array.\n     * @param {number} y - The y-position of where you want to add the row.\n     * @returns {gridl} The same gridl instance.\n     */\n    function addRow(row, y) {\n        const { data, rows, columns} = state;\n        if (y < 0 || y > rows) {\n            throw new Error(`Trying to add row at an invalid position. Given: ${y}`);\n        }\n        if (row.length !== columns) {\n            throw new Error(`Trying to add a row that contains an invalid amount of cells. Expected: ${columns}, Given: ${row.length}`);\n        }\n        const grid = unflatten(data, columns);\n        grid.splice(y, 0, row);\n        state.data = flatten(grid);\n        state.rows = grid.length;\n        return context;\n    }\n\n    /**\n     * Remove a row at a certain y-position. This changes the size of the grid.\n     *\n     * @memberOf gridl\n     * @method\n     * @instance\n     *\n     * @param {number} y - The y-position of the row you want to remove.\n     * @returns {gridl} The same gridl instance.\n     */\n    function removeRow(y) {\n        const { data, rows, columns} = state;\n        if (y < 0 || y >= rows) {\n            throw new Error(`Trying to remove a row at an invalid position. Given: ${y}`);\n        }\n        if (rows <= 1) {\n            throw new Error('Cannot remove row because the grid would be empty after it.');\n        }\n        const grid = unflatten(data, columns);\n        grid.splice(y, 1);\n        state.data = flatten(grid);\n        state.rows = grid.length;\n        return context;\n    }\n\n    return {\n        methods: {\n            addRow,\n            numRows,\n            removeRow,\n            row,\n        },\n    };\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/plugins/rows.js","import gridl from '../index';\nimport { flatten, unflatten, validateGridArray } from '../utils';\n\nexport default function(context, state) {\n\n    /**\n     * Get the current size of the grid.\n     *\n     * @memberOf gridl\n     * @method\n     * @instance\n     *\n     * @returns {number[]}\n     */\n    function size() {\n        const { columns, rows } = state;\n        return [columns, rows];\n    }\n\n    /**\n     * Exports a copy of the internal data as two-dimensional array or imports a new data into the array. If you use it to import new grid data, make sure the new data has the same size.\n     *\n     * @memberOf gridl\n     * @method\n     * @instance\n     *\n     * @param {Array.<Array.<*>>} [newData] The new data you want to import as a two-dimensional grid array.\n     * @returns {Array.<Array.<*>>} The data as two-dimensional array or the same gridl instance if you use it as a setter.\n     */\n    function data(newData) {\n        if (arguments.length) {\n            validateGridArray(newData);\n            state.data = flatten(newData);\n            return context;\n        }\n        return unflatten(state.data, state.columns);\n    }\n\n    /**\n     * Exports all entries as an one dimensional array.\n     *\n     * @memberOf gridl\n     * @method\n     * @instance\n     *\n     * @returns {Array.<*>}\n     */\n    function list() {\n        return ([...state.data]);\n    }\n\n    /**\n     * Make a clone of the current gridl instance.\n     *\n     * @memberOf gridl\n     * @method\n     * @instance\n     *\n     * @returns {gridl} A new gridl instance.\n     */\n    function clone() {\n        const { data, columns, position } = state;\n        return gridl(unflatten(data, columns)).goto(position);\n    }\n\n    return {\n        methods: {\n            size,\n            data,\n            list,\n            clone,\n        },\n    };\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/plugins/state.js","import { flatten, isNotInArea, pos2index, unflatten } from '../utils';\n\nconst _swap = (arr, i1, i2) => {\n    const tmp = arr[i1];\n    arr[i1] = arr[i2];\n    arr[i2] = tmp;\n    return arr;\n};\n\nconst _swapCells = (data, columns, rows, position1, position2) => {\n    const size = [columns, rows];\n    if (isNotInArea(size, position1) || isNotInArea(size, position2)) {\n        throw new Error('Trying to swap cells with an invalid position.');\n    }\n    const index1 = pos2index(position1, columns);\n    const index2 = pos2index(position2, columns);\n    return _swap(data, index1, index2);\n};\n\nexport default function(context, state) {\n\n\n    /**\n     * Swaps the values of the cell at the current position and another cell.<br>\n     * The current position can be defined by [goto(position)]{@link gridl#goto} or [walk(direction)]{@link gridl#walk}.\n     *\n     * @memberOf gridl\n     * @method\n     * @instance\n     *\n     * @param {Array.<number>} otherPosition - The position of the first cell.\n     * @returns {gridl} The same gridl instance.\n     */\n    function swapCell(otherPosition) {\n        const { data, columns, rows, position } = state;\n        _swapCells(data, columns, rows, position, otherPosition);\n        return context;\n    }\n\n    /**\n     * Swaps the values of two cells.\n     *\n     * @memberOf gridl\n     * @method\n     * @instance\n     *\n     * @param {Array.<number>} position1 - The position of the first cell.\n     * @param {Array.<number>} position2 - The position of the second cell.\n     * @returns {gridl} The same gridl instance.\n     */\n    function swapCells(position1, position2) {\n        const { data, columns, rows } = state;\n        _swapCells(data, columns, rows, position1, position2);\n        return context;\n    }\n\n    /**\n     * Swaps the values of two columns.\n     *\n     * @memberOf gridl\n     * @method\n     * @instance\n     *\n     * @param {Array.<number>} x1 - The x-position of the first column.\n     * @param {Array.<number>} x2 - The x-position of the second column.\n     * @returns {gridl} The same gridl instance.\n     */\n    function swapColumns(x1, x2) {\n        const { data, columns } = state;\n        if (x1 < 0 || x1 >= columns) {\n            throw new Error(`Trying to swap columns from an invalid position. Given: ${x1}`);\n        }\n        if (x2 < 0 || x2 >= columns) {\n            throw new Error(`Trying to swap columns to an invalid position. Given: ${x2}`);\n        }\n        const grid = unflatten(data, columns).map(row => {\n            _swap(row, x1, x2);\n            return row;\n        });\n        state.data = flatten(grid);\n        return context;\n    }\n\n    /**\n     * Swaps the values of two rows.\n     *\n     * @memberOf gridl\n     * @method\n     * @instance\n     *\n     * @param {Array.<number>} y1 - The y-position of the first row.\n     * @param {Array.<number>} y2 - The y-position of the second row.\n     * @returns {gridl} The same gridl instance.\n     */\n    function swapRows(y1, y2) {\n        const { data, columns, rows } = state;\n        if (y1 < 0 || y1 >= rows) {\n            throw new Error(`Trying to swap rows from an invalid position. Given: ${y1}`);\n        }\n        if (y2 < 0 || y2 >= rows) {\n            throw new Error(`Trying to swap rows to an invalid position. Given: ${y2}`);\n        }\n        state.data = flatten(_swap(unflatten(data, columns), y1, y2));\n        return context;\n    }\n\n    return {\n        methods: {\n            swapCell,\n            swapCells,\n            swapColumns,\n            swapRows,\n        },\n    };\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/plugins/swapping.js","import { getValueAt, setValueAt } from '../utils';\n\nexport default function(context, state) {\n\n    /**\n     * Get or set the value at the current position.<br>\n     * It returns the cell's value if you provide no value and sets it if you do provide a value.\n     *\n     * @memberOf gridl\n     * @method\n     * @instance\n     *\n     * @param {*} [value] - The value you want to set or <code>undefined</code> if you want to get the value.\n     * @returns {*} The cell's value or the gridl instance if you use it as a setter.\n     */\n    function value(value) {\n        const { data, columns, rows, position } = state;\n        if (arguments.length < 1) {\n            return getValueAt(data, columns, position);\n        }\n        setValueAt(data, columns, rows, position, value);\n        return context;\n    }\n\n    /**\n     * Get or set the value at a certain position.<br>\n     * It returns the cell's value if you provide no value and sets it if you do provide a value.\n     *\n     * @memberOf gridl\n     * @method\n     * @instance\n     *\n     * @param {Array.<number>} pos - The position where you want to set or get the value.\n     * @param {*} [value] - The value you want to set or <code>undefined</code> if you want to get the value.\n     * @returns {*} The cell's value or the the same gridl instance if you use it as a setter.\n     */\n    function valueAt(pos, value) {\n        const { data, columns, rows } = state;\n        if (arguments.length < 2) {\n            return getValueAt(data, columns, pos);\n        }\n        setValueAt(data, columns, rows, pos, value);\n        return context;\n    }\n\n    return { methods: { value, valueAt } };\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/plugins/value.js","import directions from './directions';\n\n/**\n * Predefined lists of adjacent positions relative to a certain position.\n *\n * @namespace\n *\n * @type {Object}\n * @property {number[][]} ALL - all direct adjacent positions (orthogonal + diagonal) in the order: left to right, top to bottom\n * @property {number[][]} ALL_CW - all direct adjacent positions (orthogonal + diagonal) in clockwise order\n * @property {number[][]} ALL_CCW - all direct adjacent positions (orthogonal + diagonal) in counterclockwise order\n * @property {number[][]} ORTHOGONAL - all orthogonal adjacent positions in the order: left to right, top to bottom\n * @property {number[][]} ORTHOGONAL_CW - all orthogonal adjacent positions in clockwise order\n * @property {number[][]} ORTHOGONAL_CCW - all orthogonal adjacent positions in counterclockwise order\n * @property {number[][]} DIAGONAL - all diagonal adjacent positions in the order: left to right, top to bottom\n * @property {number[][]} DIAGONAL_CW - all diagonal adjacent positions in clockwise order\n * @property {number[][]} DIAGONAL_CCW - all diagonal adjacent positions in counterclockwise order\n */\nconst adjacences = Object.freeze({\n    ALL: Object.freeze([\n        directions.UP_LEFT,\n        directions.UP,\n        directions.UP_RIGHT,\n        directions.LEFT,\n        directions.RIGHT,\n        directions.DOWN_LEFT,\n        directions.DOWN,\n        directions.DOWN_RIGHT,\n    ]),\n    ALL_CW: Object.freeze([\n        directions.UP,\n        directions.UP_RIGHT,\n        directions.RIGHT,\n        directions.DOWN_RIGHT,\n        directions.DOWN,\n        directions.DOWN_LEFT,\n        directions.LEFT,\n        directions.UP_LEFT,\n    ]),\n    ALL_CCW: Object.freeze([\n        directions.UP,\n        directions.UP_LEFT,\n        directions.LEFT,\n        directions.DOWN_LEFT,\n        directions.DOWN,\n        directions.DOWN_RIGHT,\n        directions.RIGHT,\n        directions.UP_RIGHT,\n    ]),\n    ORTHOGONAL: Object.freeze([\n        directions.UP,\n        directions.LEFT,\n        directions.RIGHT,\n        directions.DOWN,\n    ]),\n    ORTHOGONAL_CW: Object.freeze([\n        directions.UP,\n        directions.RIGHT,\n        directions.DOWN,\n        directions.LEFT,\n    ]),\n    ORTHOGONAL_CCW: Object.freeze([\n        directions.UP,\n        directions.LEFT,\n        directions.DOWN,\n        directions.RIGHT,\n    ]),\n    DIAGONAL: Object.freeze([\n        directions.UP_LEFT,\n        directions.UP_RIGHT,\n        directions.DOWN_LEFT,\n        directions.DOWN_RIGHT,\n    ]),\n    DIAGONAL_CW: Object.freeze([\n        directions.UP_RIGHT,\n        directions.DOWN_RIGHT,\n        directions.DOWN_LEFT,\n        directions.UP_LEFT,\n    ]),\n    DIAGONAL_CCW: Object.freeze([\n        directions.UP_LEFT,\n        directions.DOWN_LEFT,\n        directions.DOWN_RIGHT,\n        directions.UP_RIGHT,\n    ]),\n});\n\nexport default adjacences;\n\n\n// WEBPACK FOOTER //\n// ./src/adjacences.js"],"sourceRoot":""}