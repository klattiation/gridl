{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///gridl.min.js","webpack:///webpack/bootstrap 7204d0b05b1ce076b999","webpack:///./src/index.js"],"names":["root","factory","exports","module","define","amd","self","this","modules","__webpack_require__","moduleId","installedModules","i","l","call","m","c","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","n","__esModule","object","property","prototype","hasOwnProperty","p","s","_toConsumableArray","arr","Array","isArray","arr2","length","from","_isValidGridArray","data","Error","forEach","row","_getValueAt","_data","columns","pos","index","_pos2index","isNaN","_setValueAt","api","rows","value","_isNotInArea","_setAreaAt","position","area","anchor","arguments","undefined","_subtractPositions","r","targetPos","cell","setValueAt","_getAreaAt","size","posTmp","end","Math","min","max","rArea","cArea","valueAt","_find","callback","findIndex","_index2pos","_findInArea","getAreaAt","flat","_flatten","areaIndex","v","areaColumns","posInArea","_checkAreaFitsAt","fitsHorizontally","fitsVertically","_goto","_walk","startPos","direction","_addPositions","_moveCell","to","fromIndex","toIndex","_move","_moveRow","_grid","_columns","_rows","yFrom","yTo","_moveColumn","grid","xFrom","xTo","newGrid","map","_addRowAt","y","splice","_addColumnAt","column","x","_removeRowAt","_removeColumnAt","filter","_clip","endPoint","_swapCells","pos1","pos2","tmp","_swapRows","y1","y2","_swap","_swapColumns","x1","x2","_rotate","steps","mod","_getColumn","reverse","_mirror","limitedIdx","_limit","left","concat","_adjacentCells","adjacence","gridSize","reduce","res","absPos","_reduceAreaAt","initialValue","hasInitialValue","_isValidPositionFormat","reducer","acc","local","global","flattenedArea","gridl","_this","_position","numColumns","numRows","setValue","moveCell","moveAbs","moveRel","moveRow","moveColumn","_getRow","addRow","addColumn","removeRow","removeColumn","clipAt","clip","swapCells","position1","position2","swapCell","swapRows","swapColumns","setAreaAt","setArea","getArea","areaFitsAt","areaFits","find","findInArea","_toArray2D","rotate","mirrorX","xPos","mirrorY","yPos","goto","walk","newData","_this2","reduceAreaAt","reduceArea","clone","adjacentCellsAt","adjacences","ALL","includeOutsideValues","adjacentCells","list","makeGrid","parsedColumns","parseInt","parsedRows","vr","vc","makeList","parsedLength","make","Number","isSafeInteger","floor","array1D","array2D","p1","p2","i1","i2","areaSize","directions","freeze","UP","UP_RIGHT","RIGHT","DOWN_RIGHT","DOWN","DOWN_LEFT","LEFT","UP_LEFT","ALL_CW","ALL_CCW","ORTHOGONAL","ORTHOGONAL_CW","ORTHOGONAL_CCW","DIAGONAL","DIAGONAL_CW","DIAGONAL_CCW","gridlFactory","default"],"mappings":"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","file":"gridl.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"gridl\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"gridl\"] = factory();\n\telse\n\t\troot[\"gridl\"] = factory();\n})(typeof self !== 'undefined' ? self : this, function() {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"gridl\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"gridl\"] = factory();\n\telse\n\t\troot[\"gridl\"] = factory();\n})(typeof self !== 'undefined' ? self : this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.makeGrid = makeGrid;\nexports.makeList = makeList;\nexports.make = make;\n\nfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\nfunction _isValidGridArray(data) {\n    if (!Array.isArray(data)) {\n        throw new Error('Trying to import data that is not an array.');\n    }\n    data.forEach(function (row, i) {\n        if (!Array.isArray(row)) {\n            throw new Error('Trying to import data that is not an array.');\n        }\n        if (i > 0 && data[i - 1].length !== row.length) {\n            throw new Error('Trying to import data with different row lengths.');\n        }\n        if (row.length < 1) {\n            throw new Error('Trying to import grid without any columns. You need to provide at least one column.');\n        }\n    });\n}\n\nvar _isValidPositionFormat = function _isValidPositionFormat(pos) {\n    if (!Array.isArray(pos) || pos.length !== 2) {\n        return false;\n    }\n    return Number.isSafeInteger(pos[0]) && Number.isSafeInteger(pos[1]);\n};\n\nvar _index2pos = function _index2pos(index, columns) {\n    return [index % columns, Math.floor(index / columns)];\n};\n\nvar _pos2index = function _pos2index(position, columns) {\n    return position && position[0] + position[1] * columns;\n};\n\nvar _toArray2D = function _toArray2D(array1D, columns) {\n    return array1D.reduce(function (res, cell, index) {\n        var pos = _index2pos(index, columns);\n        if (!res[pos[1]]) {\n            res[pos[1]] = [];\n        }\n        res[pos[1]][pos[0]] = cell;\n        return res;\n    }, []);\n};\n\nvar _flatten = function _flatten(array2D) {\n    return array2D.reduce(function (res, row) {\n        return [].concat(_toConsumableArray(res), _toConsumableArray(row));\n    }, []);\n};\n\nvar _getColumn = function _getColumn(data, x) {\n    if (x >= 0 && x < data[0].length) {\n        return data.map(function (row) {\n            return row[x];\n        });\n    }\n};\n\nvar _getRow = function _getRow(data, y) {\n    return data[y];\n};\n\nvar _addPositions = function _addPositions(p1, p2) {\n    return [p1[0] + p2[0], p1[1] + p2[1]];\n};\n\nvar _subtractPositions = function _subtractPositions(p1, p2) {\n    return [p1[0] - p2[0], p1[1] - p2[1]];\n};\n\nvar _limit = function _limit(v, min, max) {\n    return Math.max(Math.min(v, max), min);\n};\n\nvar _swap = function _swap(arr, i1, i2) {\n    var tmp = arr[i1];\n    arr[i1] = arr[i2];\n    arr[i2] = tmp;\n};\n\nvar _move = function _move(data, fromIndex, toIndex) {\n    var cell = data[fromIndex];\n    data.splice(fromIndex, 1);\n    data.splice(toIndex, 0, cell);\n    return data;\n};\n\nvar _isNotInArea = function _isNotInArea(areaSize, position) {\n    return position[0] < 0 || position[0] >= areaSize[0] || position[1] < 0 || position[1] >= areaSize[1];\n};\n\nfunction _getValueAt(_data, columns, pos) {\n    var index = _pos2index(pos, columns);\n    if (isNaN(index)) {\n        return;\n    }\n    return _data[index];\n}\n\nfunction _setValueAt(api, _data, columns, rows, pos, value) {\n    if (_isNotInArea([columns, rows], pos)) {\n        return api;\n    }\n    var index = _pos2index(pos, columns);\n    if (!isNaN(index)) {\n        _data[index] = value;\n    }\n    return api;\n}\n\nfunction _setAreaAt(api, columns, rows, position, area) {\n    var anchor = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : [0, 0];\n\n    var pos = _subtractPositions(position, anchor);\n    area.forEach(function (row, r) {\n        var targetPos = [0, r + pos[1]];\n        if (targetPos[1] >= rows) {\n            return;\n        }\n        row.forEach(function (cell, c) {\n            targetPos[0] = c + pos[0];\n            if (targetPos[0] >= columns) {\n                return;\n            }\n            api.setValueAt(targetPos, cell);\n        });\n    });\n    return api;\n}\n\nfunction _getAreaAt(api, columns, rows, position, size) {\n    var anchor = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : [0, 0];\n\n    var posTmp = _subtractPositions(position, anchor);\n    var end = [Math.min(posTmp[0] + size[0], columns), Math.min(posTmp[1] + size[1], rows)];\n    var pos = [Math.max(0, posTmp[0]), Math.max(0, posTmp[1])];\n    var area = [];\n    for (var r = pos[1]; r < end[1]; r++) {\n        var rArea = r - pos[1];\n        if (!area[rArea]) {\n            area[rArea] = [];\n        }\n        for (var c = pos[0]; c < end[0]; c++) {\n            var cArea = c - pos[0];\n            area[rArea][cArea] = api.valueAt([c, r]);\n        }\n    }\n    return area;\n}\n\nfunction _find(columns, data, callback) {\n    var index = data.findIndex(callback);\n    return index >= 0 ? _index2pos(index, columns) : undefined;\n}\n\nfunction _findInArea(api, columns, pos, size, callback) {\n    var area = api.getAreaAt(pos, size);\n    var flat = _flatten(area);\n    var areaIndex = flat.findIndex(function (v, i) {\n        return callback(v, _index2pos(i, columns), api);\n    });\n    if (areaIndex >= 0) {\n        var areaColumns = area[0].length;\n        var posInArea = _index2pos(areaIndex, areaColumns);\n        return [pos[0] + posInArea[0], pos[1] + posInArea[1]];\n    }\n}\n\nfunction _checkAreaFitsAt(columns, rows, position, area) {\n    var anchor = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : [0, 0];\n\n    var pos = _subtractPositions(position, anchor);\n    var fitsHorizontally = pos[0] >= 0 && pos[0] + area[0].length <= columns;\n    var fitsVertically = pos[1] >= 0 && pos[1] + area.length <= rows;\n    return fitsHorizontally && fitsVertically;\n}\n\nfunction _goto(columns, rows, position) {\n    if (!Array.isArray(position)) {\n        throw new Error('Trying to go to an invalid position. Given: ' + position);\n    }\n    // if (_isNotInArea([columns, rows], position)) {\n    //     throw new Error(`Trying to go to an invalid position. Given: ${position}`);\n    // }\n    return position;\n}\n\nfunction _walk(columns, rows, startPos, direction) {\n    var targetPos = _addPositions(startPos, direction);\n    if (_isNotInArea([columns, rows], targetPos)) {\n        throw new Error('Trying to walk to an invalid position. Position: ' + targetPos);\n    }\n    return targetPos;\n}\n\nfunction _moveCell(data, columns, rows, from, to) {\n    var fromIndex = _pos2index(from, columns);\n    var size = [columns, rows];\n    if (isNaN(fromIndex) || _isNotInArea(size, from)) {\n        throw new Error('Trying to move cell from an invalid position. Given: [' + from + ']');\n    }\n    var toIndex = _pos2index(to, columns);\n    if (isNaN(toIndex) || _isNotInArea(size, to)) {\n        throw new Error('Trying to move cell to an invalid position. Given: [' + to + ']');\n    }\n    _move(data, fromIndex, toIndex);\n}\n\nfunction _moveRow(_grid, _columns, _rows, yFrom, yTo) {\n    if (yFrom < 0 || yFrom >= _rows) {\n        throw new Error('Trying to move row from an invalid position. Given: ' + yFrom);\n    }\n    if (yTo < 0 || yTo >= _rows) {\n        throw new Error('Trying to move row to an invalid position. Given: ' + yTo);\n    }\n    return _flatten(_move(_grid, yFrom, yTo));\n}\n\nfunction _moveColumn(grid, columns, rows, xFrom, xTo) {\n    if (xFrom < 0 || xFrom >= columns) {\n        throw new Error('Trying to move column from an invalid position. Given: ' + xFrom);\n    }\n    if (xTo < 0 || xTo >= columns) {\n        throw new Error('Trying to move column to an invalid position. Given: ' + xTo);\n    }\n    var newGrid = grid.map(function (row) {\n        return _move(row, xFrom, xTo);\n    });\n    return _flatten(newGrid);\n}\n\nfunction _addRowAt(grid, columns, rows, row, y) {\n    if (y < 0 || y > rows) {\n        throw new Error('Trying to add row at an invalid position. Given: ' + y);\n    }\n    if (row.length !== columns) {\n        throw new Error('Trying to add a row that contains an invalid amount of cells. Expected: ' + columns + ', Given: ' + row.length);\n    }\n    grid.splice(y, 0, row);\n    return grid;\n}\n\nfunction _addColumnAt(grid, columns, rows, column, x) {\n    if (x < 0 || x > columns) {\n        throw new Error('Trying to add column at an invalid position. Given: ' + x);\n    }\n    if (column.length !== rows) {\n        throw new Error('Trying to add a column that contains an invalid amount of cells. Expected: ' + rows + ', Given: ' + column.length);\n    }\n    return grid.map(function (row, i) {\n        row.splice(x, 0, column[i]);\n        return row;\n    });\n}\n\nfunction _removeRowAt(grid, rows, y) {\n    if (y < 0 || y >= rows) {\n        throw new Error('Trying to remove a row at an invalid position. Given: ' + y);\n    }\n    if (rows <= 1) {\n        throw new Error('Cannot remove row because the grid would be empty after it.');\n    }\n    grid.splice(y, 1);\n    return grid;\n}\n\nfunction _removeColumnAt(grid, columns, x) {\n    if (x < 0 || x >= columns) {\n        throw new Error('Trying to remove a column at an invalid position. Given: ' + x);\n    }\n    if (columns <= 1) {\n        throw new Error('Cannot remove column because the grid would be empty after it.');\n    }\n    return grid.map(function (row) {\n        return row.filter(function (v, c) {\n            return c !== x;\n        });\n    });\n}\n\nfunction _clip(grid, _columns, _rows, position, size) {\n    if (position[0] < 0 || position[0] >= _columns || position[1] < 0 || position[1] >= _rows) {\n        throw new Error('Trying to clip data at an invalid position. Given: ' + position);\n    }\n    var endPoint = _addPositions(position, size);\n    return grid.filter(function (row, r) {\n        return r >= position[1] && r < endPoint[1];\n    }).map(function (row) {\n        return row.filter(function (cell, c) {\n            return c >= position[0] && c < endPoint[0];\n        });\n    });\n}\n\nfunction _swapCells(api, pos1, pos2) {\n    var size = api.size();\n    if (_isNotInArea(size, pos1) || _isNotInArea(size, pos2)) {\n        throw new Error('Trying to swap cells with an invalid position.');\n    }\n    var tmp = api.valueAt(pos1);\n    api.setValueAt(pos1, api.valueAt(pos2));\n    api.setValueAt(pos2, tmp);\n    return api;\n}\n\nfunction _swapRows(grid, rows, y1, y2) {\n    if (y1 < 0 || y1 >= rows) {\n        throw new Error('Trying to swap rows from an invalid position. Given: ' + y1);\n    }\n    if (y2 < 0 || y2 >= rows) {\n        throw new Error('Trying to swap rows to an invalid position. Given: ' + y2);\n    }\n    _swap(grid, y1, y2);\n    return _flatten(grid);\n}\n\nfunction _swapColumns(grid, columns, x1, x2) {\n    if (x1 < 0 || x1 >= columns) {\n        throw new Error('Trying to swap columns from an invalid position. Given: ' + x1);\n    }\n    if (x2 < 0 || x2 >= columns) {\n        throw new Error('Trying to swap columns to an invalid position. Given: ' + x2);\n    }\n    grid.map(function (row) {\n        _swap(row, x1, x2);\n        return row;\n    });\n    return _flatten(grid);\n}\n\nfunction _rotate(grid, columns, steps) {\n    var mod = steps % 4;\n    var option = mod < 0 ? mod + 4 : mod;\n    switch (option) {\n        case 0:\n            return grid;\n        case 1:\n            return Array.from({ length: columns }, function (v, i) {\n                return _getColumn(grid, i).reverse();\n            });\n        case 2:\n            return grid.reverse().map(function (row, r) {\n                return row.reverse();\n            });\n        case 3:\n            return Array.from({ length: columns }, function (v, i) {\n                return _getColumn(grid, columns - 1 - i);\n            });\n        default:\n            throw new Error('Trying to rotate the grid with an invalid steps parameter. Given: ' + steps);\n    }\n}\n\nfunction _mirror(arr, index) {\n    if (index === undefined) {\n        return arr.reverse();\n    }\n    var limitedIdx = _limit(index, 0, arr.length - 1);\n    var left = arr.filter(function (v, i) {\n        return i < limitedIdx;\n    });\n    var right = arr.filter(function (v, i) {\n        return i > limitedIdx;\n    });\n    return [].concat(_toConsumableArray(right.reverse()), [arr[limitedIdx]], _toConsumableArray(left.reverse()));\n}\n\nfunction _adjacentCells(grid, position, adjacence) {\n    var gridSize = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n\n    return adjacence.reduce(function (res, direction) {\n        var absPos = _addPositions(position, direction);\n        var value = grid && grid[absPos[1]] && grid[absPos[1]][absPos[0]];\n        if (gridSize) {\n            return _isNotInArea(gridSize, absPos) ? res : [].concat(_toConsumableArray(res), [value]);\n        } else {\n            return [].concat(_toConsumableArray(res), [value]);\n        }\n    }, []);\n}\n\nfunction _reduceAreaAt(api, columns, rows, position, size, callback, initialValue, hasInitialValue) {\n    if (!_isValidPositionFormat(position)) {\n        throw new Error('Trying to reduce an area at an invalid position.');\n    }\n    if (!_isValidPositionFormat(size)) {\n        throw new Error('Trying to reduce an area with invalid size.');\n    }\n    var reducer = function reducer(acc, v, i) {\n        var local = _index2pos(i, size[0]);\n        var global = _addPositions(local, position);\n        return callback(acc, v, global, api);\n    };\n    var flattenedArea = _flatten(_getAreaAt(api, columns, rows, position, size));\n    return hasInitialValue ? flattenedArea.reduce(reducer) : flattenedArea.reduce(reducer, initialValue);\n}\n\n/**\n * Generates a new gridl instance.\n *\n * @constructor\n * @param {Array} data - A two-dimsensional grid array. Every row needs to have the same length.\n * @returns {gridl} The new gridl instance.\n */\nfunction gridl(data) {\n    var _this = this;\n\n    /**\n     * @callback iteratorCallback\n     * @param {*} cell - The value of the current cell.\n     * @param {Array.<number>} position - The current position.\n     * @param {gridl} gridlInstance - The current gridl instance.\n     */\n\n    /**\n     * @callback reducerCallback\n     * @param {*} accumulator - The accumulator accumulates the callback's return values; it is the accumulated value previously returned in the last invocation of the callback, or initialValue, if supplied.\n     * @param {*} cell - The value of the current cell.\n     * @param {Array.<number>} position - The current position.\n     * @param {gridl} gridlInstance - The current gridl instance.\n     */\n\n    _isValidGridArray(data);\n\n    var _rows = data.length;\n    var _columns = data[0].length;\n    var _data = _flatten(data);\n    var _position = [0, 0];\n\n    /**\n     * get the number of columns.\n     */\n    this.numColumns = function () {\n        return _columns;\n    };\n\n    /**\n     * Get the number of rows.\n     * @returns {number}\n     */\n    this.numRows = function () {\n        return _rows;\n    };\n\n    /**\n     * Get the current size of the grid.\n     *\n     * @returns {number[]}\n     */\n    this.size = function () {\n        return [_columns, _rows];\n    };\n\n    /**\n     * Set the value at the current position. You can also set the cell to <code>undefined</code>\n     * The current position can be defined by [goto(position)]{@link gridl#goto} or [walk(direction)]{@link gridl#walk}.\n     *\n     * @param {*} value - The value the cell should have.\n     */\n    this.setValue = function (value) {\n        return _setValueAt(_this, _data, _columns, _rows, _position, value);\n    };\n\n    /**\n     * Get or set the value at the current position.<br>\n     * It returns the cell's value if you provide no value and sets it if you do provide a value.<br>\n     * To explicitly set the value to <code>undefined</code> use [setValue()]{@link gridl#setValue}.\n     *\n     * @param {*} value - The value you want to set or <code>undefined</code> if you want to get the value.\n     * @returns {*} The cell's value or the gridl instance if you use it as a setter.\n     */\n    this.value = function (value) {\n        return value === undefined ? _getValueAt(_data, _columns, _position) : _setValueAt(_this, _data, _columns, _rows, _position, value);\n    };\n\n    /**\n     * Set the value at a certain position. You can also set the cell to <code>undefined</code>\n     *\n     * @param {Array.<number>} pos - The position where you want to set the value.\n     * @param {*} value - The value you want to set.\n     * @returns {gridl} The same gridl instance.\n     */\n    this.setValueAt = function (pos, value) {\n        return _setValueAt(_this, _data, _columns, _rows, pos, value);\n    };\n\n    /**\n     * Get or set the value at a certain position.<br>\n     * It returns the cell's value if you provide no value and sets it if you do provide a value.<br>\n     * To explicitly set the value to <code>undefined</code> use [setValueAt()]{@link gridl#setValueAt}.\n     *\n     * @param {Array.<number>} pos - The position where you want to set or get the value.\n     * @param {*} value - The value you want to set or <code>undefined</code> if you want to get the value.\n     * @returns {*} The cell's value or the the same gridl instance if you use it as a setter.\n     */\n    this.valueAt = function (pos, value) {\n        return value === undefined ? _getValueAt(_data, _columns, pos) : _setValueAt(_this, _data, _columns, _rows, pos, value);\n    };\n\n    /**\n     * Move a cell from one position to another.\n     *\n     * @param {Array} from - The position of the cell that you want to move.\n     * @param {Array} to - The position where the cell should be moved.\n     * @returns {gridl} - The current gridl instance.\n     */\n    this.moveCell = function (from, to) {\n        _moveCell(_data, _columns, _rows, from, to);\n        return _this;\n    };\n\n    /**\n     * Move the current cell to an absolute position.\n     * The current position can be defined by [goto(position)]{@link gridl#goto} or [walk(direction)]{@link gridl#walk}.\n     *\n     * @param {Array} to - The position where the cell should be moved.\n     * @returns {gridl}\n     */\n    this.moveAbs = function (to) {\n        _moveCell(_data, _columns, _rows, _position, to);\n        return _this;\n    };\n\n    /**\n     * Move the current cell from the current position in a certain direction.\n     * The current position can be defined by [goto(position)]{@link gridl#goto} or [walk(direction)]{@link gridl#walk}.\n     *\n     * @param {Array} direction - The direction in which to move from the current position.\n     * @returns {gridl} The current gridl instance.\n     */\n    this.moveRel = function (direction) {\n        return _this.moveCell(_position, _addPositions(_position, direction));\n    };\n\n    /**\n     * Move a row to a certain position.\n     *\n     * @param {number} yFrom - The position on the y-axis of the row you want to move.\n     * @param {number} yTo - The position on the y-axis of where the row should be moved to.\n     * @returns {gridl} The current gridl instance.\n     */\n    this.moveRow = function (yFrom, yTo) {\n        _data = _moveRow(_this.data(), _columns, _rows, yFrom, yTo);\n        return _this;\n    };\n\n    /**\n     * Move a column to a certain position.\n     *\n     * @param {number} xFrom - The position on the x-axis of the column you want to move.\n     * @param {number} xTo - The position on the x-axis of where the column should be moved.\n     * @returns {gridl}\n     */\n    this.moveColumn = function (xFrom, xTo) {\n        _data = _moveColumn(_this.data(), _columns, _rows, xFrom, xTo);\n        return _this;\n    };\n\n    /**\n     * Get the column at a certain x-position\n     *\n     * @param {number} x - The x-position of the column you want to get.\n     * @returns {Array.<*>}\n     */\n    this.column = function (x) {\n        return _getColumn(_this.data(), x);\n    };\n\n    /**\n     * Get the row at a certain y-position\n     *\n     * @param {number} y - The y-position of the row you want to get.\n     * @returns {Array.<*>}\n     */\n    this.row = function (y) {\n        return _getRow(_this.data(), y);\n    };\n\n    /**\n     * Add a row at a certain y-position. This changes the size of the grid.\n     *\n     * @param {Array.<*>} row - The row you want to add as an one-dimensional array.\n     * @param {number} y - The y-position of where you want to add the row.\n     * @returns {gridl} The same gridl instance.\n     */\n    this.addRow = function (row, y) {\n        var grid = _addRowAt(_this.data(), _columns, _rows, row, y);\n        _data = _flatten(grid);\n        _rows = grid.length;\n        return _this;\n    };\n\n    /**\n     * Add a column at a certain x-position. This changes the size of the grid.\n     *\n     * @param {Array.<*>} column - The column you want to add as an one-dimensional array.\n     * @param {number} x - The x-position of where you want to add the column.\n     * @returns {gridl} The same gridl instance.\n     */\n    this.addColumn = function (column, x) {\n        var grid = _addColumnAt(_this.data(), _columns, _rows, column, x);\n        _data = _flatten(grid);\n        _columns = grid[0].length;\n        return _this;\n    };\n\n    /**\n     * Remove a row at a certain y-position. This changes the size of the grid.\n     *\n     * @param {number} y - The y-position of the row you want to remove.\n     * @returns {gridl} The same gridl instance.\n     */\n    this.removeRow = function (y) {\n        var grid = _removeRowAt(_this.data(), _rows, y);\n        _data = _flatten(grid);\n        _rows = grid.length;\n        return _this;\n    };\n\n    /**\n     * Remove a column at a certain x-position. This changes the size of the grid.\n     *\n     * @param {number} x - The x-position of the column you want to remove.\n     * @returns {gridl} The same gridl instance.\n     */\n    this.removeColumn = function (x) {\n        var grid = _removeColumnAt(_this.data(), _columns, x);\n        _data = _flatten(grid);\n        _columns = grid[0].length;\n        return _this;\n    };\n\n    /**\n     * Clip an area out of the current grid. It removes all cells that are not inside the given area.\n     *\n     * @param {Array.<number>} position - The position the area.\n     * @param {Array.<number>} size - The size of the area.\n     * @returns {gridl} The same gridl instance.\n     */\n    this.clipAt = function (position, size) {\n        var grid = _clip(_this.data(), _columns, _rows, position, size);\n        _data = _flatten(grid);\n        _rows = grid.length;\n        _columns = grid[0].length;\n        return _this;\n    };\n\n    /**\n     * Clip an area out of the current grid at the current position. It removes all cells that are not inside the given area.<br>\n     * The current position can be defined by [goto(position)]{@link gridl#goto} or [walk(direction)]{@link gridl#walk}.\n     *\n     * @param {Array.<number>} size - The size of the area.\n     * @returns {gridl} The same gridl instance.\n     */\n    this.clip = function (size) {\n        return _this.clipAt(_position, size);\n    };\n\n    /**\n     * Swap the values of two cells.\n     *\n     * @param {Array.<number>} position1 - The position of the first cell.\n     * @param {Array.<number>} position2 - The position of the second cell.\n     * @returns {gridl} The same gridl instance.\n     */\n    this.swapCells = function (position1, position2) {\n        return _swapCells(_this, position1, position2);\n    };\n\n    /**\n     * Swaps the values of the cell at the current position and another cell.<br>\n     * The current position can be defined by [goto(position)]{@link gridl#goto} or [walk(direction)]{@link gridl#walk}.\n     *\n     * @param {Array.<number>} position - The position of the first cell.\n     * @returns {gridl} The same gridl instance.\n     */\n    this.swapCell = function (position) {\n        return _swapCells(_this, _position, position);\n    };\n\n    /**\n     * Swaps the values of two rows.\n     *\n     * @param {Array.<number>} y1 - The y-position of the first row.\n     * @param {Array.<number>} y2 - The y-position of the second row.\n     * @returns {gridl} The same gridl instance.\n     */\n    this.swapRows = function (y1, y2) {\n        _data = _swapRows(_this.data(), _rows, y1, y2);\n        return _this;\n    };\n\n    /**\n     * Swaps the values of two columns.\n     *\n     * @param {Array.<number>} x1 - The x-position of the first column.\n     * @param {Array.<number>} x2 - The x-position of the second column.\n     * @returns {gridl} The same gridl instance.\n     */\n    this.swapColumns = function (x1, x2) {\n        _data = _swapColumns(_this.data(), _columns, x1, x2);\n        return _this;\n    };\n\n    /**\n     * Overwrite the values of a given area at a certain position.\n     *\n     * @param {Array.<number>} position - The position of the area.\n     * @param {Array.<number>} area - The area itself as two-dimensional grid array.\n     * @param {Array.<number>} [anchor = [0, 0]] - The center of area.\n     * @returns {gridl} The same gridl instance.\n     */\n    this.setAreaAt = function (position, area, anchor) {\n        return _setAreaAt(_this, _columns, _rows, position, area, anchor);\n    };\n\n    /**\n     * Overwrite the values of a given area at the current position.<br>\n     * The current position can be defined by [goto(position)]{@link gridl#goto} or [walk(direction)]{@link gridl#walk}.\n     *\n     * @param {Array.<number>} area - The area itself as two-dimensional grid array.\n     * @param {Array.<number>} [anchor = [0, 0]] - The center of area.\n     * @returns {gridl} The same gridl instance.\n     */\n    this.setArea = function (area, anchor) {\n        return _setAreaAt(_this, _columns, _rows, _position, area, anchor);\n    };\n\n    /**\n     * Exports the data grid array of a given array at the given position.\n     *\n     * @param {Array.<number>} position - The position of the area.\n     * @param {Array.<number>} size - The size fo the area as a two-dimensional grid array.\n     * @param {Array.<number>} [anchor = [0, 0]] - The center of area.\n     * @returns {number[][]}\n     */\n    this.getAreaAt = function (position, size, anchor) {\n        return _getAreaAt(_this, _columns, _rows, position, size, anchor);\n    };\n\n    /**\n     * Exports the data grid array of a given array at the current position.<br>\n     * The current position can be defined by [goto(position)]{@link gridl#goto} or [walk(direction)]{@link gridl#walk}.\n     *\n     * @param {Array.<number>} size - The size fo the area as a two-dimensional grid array.\n     * @param {Array.<number>} [anchor = [0, 0]] - The center of area.\n     * @returns {number[][]}\n     */\n    this.getArea = function (size, anchor) {\n        return _getAreaAt(_this, _columns, _rows, _position, size, anchor);\n    };\n\n    /**\n     * Check if a given area would fit inside the grid at a given position.\n     *\n     * @param {number[]} position - The position where the area should be placed.\n     * @param {Array.<Array.<*>>} area - The area itself as a two-dimensional grid array\n     * @param {number[]} [anchor = [0, 0]] - The center of area.\n     * @returns {boolean} Whether the area fits or not.\n     */\n    this.areaFitsAt = function (position, area, anchor) {\n        return _checkAreaFitsAt(_columns, _rows, position, area, anchor);\n    };\n\n    /**\n     * Check if a given area would fit inside the grid at the current position.<br>\n     * The current position can be defined by [goto(position)]{@link gridl#goto} or [walk(direction)]{@link gridl#walk}.\n     *\n     * @param {Array.<Array.<*>>} area - The area itself as a two-dimensional grid array\n     * @param {number[]} [anchor = [0, 0]] - The center of area.\n     * @returns {boolean} Whether the area fits or not.\n     */\n    this.areaFits = function (area, anchor) {\n        return _checkAreaFitsAt(_columns, _rows, _position, area, anchor);\n    };\n\n    /**\n     * Find the first occurrence of an element within the entire grid.\n     *\n     * @param {iteratorCallback} callback - The callback function that is called on each element. Should return true if the element is found or false if not.\n     * @returns {(Array.<number>|undefined)} The position of the first element that is found or <code>undefined</code> if nothing was found.\n     */\n    this.find = function (callback) {\n        return _find(_columns, _data, function (v, i) {\n            return callback(v, _index2pos(i, _columns), _this);\n        });\n    };\n\n    /**\n     * Find the first occurrence of an element within a certain area.\n     *\n     * @param {Array} position - The position of the area [x, y].\n     * @param {Array} size - The size of the area [columns, rows].\n     * @param {iteratorCallback} callback - The callback function that is called on each element within the defined area. Should return true if the element is found or false if not.\n     * @returns {(Array.<number>|undefined)} The position of the first element that is found or <code>undefined</code> if nothing was found.\n     */\n    this.findInArea = function (position, size, callback) {\n        return _findInArea(_this, _columns, position, size, callback);\n    };\n\n    /**\n     * Exports a copy of the internal data as two-dimensional array.\n     *\n     * @returns {Array.<Array.<*>>} The data as two-dimensional array.\n     */\n    this.data = function () {\n        return _toArray2D(_data, _columns);\n    };\n\n    /**\n     * Rotate the array in a 90 degree steps. A positive step turns it clockwise, a negative step turns it counterclockwise.\n     *\n     * @param {number} steps - The number of 90 degree turns as integer number.\n     * @returns {gridl} The same gridl instance.\n     */\n    this.rotate = function (steps) {\n        var grid = _rotate(_this.data(), _columns, steps);\n        _data = _flatten(grid);\n        _rows = grid.length;\n        _columns = grid[0].length;\n        return _this;\n    };\n\n    /**\n     * Flips the array on the given x-position\n     *\n     * @param {number} xPos - The x-position of where to flip the array.\n     * @returns {gridl} The same gridl instance.\n     */\n    this.mirrorX = function (xPos) {\n        _data = _flatten(_mirror(_this.data(), xPos));\n        return _this;\n    };\n\n    /**\n     * Flips the array on the given y-position.\n     *\n     * @param {number} yPos - The y-position of where to flip the array.\n     * @returns {gridl} The same gridl instance.\n     */\n    this.mirrorY = function (yPos) {\n        var grid = _this.data();\n        _data = _flatten(grid.map(function (row) {\n            return _mirror(row, yPos);\n        }));\n        return _this;\n    };\n\n    /**\n     * Go to an absolute position.\n     * The internal cursor will be set to this position and can then be used for further operations.\n     *\n     * @param {Array} position - The new position.\n     * @returns {gridl}\n     */\n    this.goto = function (position) {\n        var pos = _goto(_columns, _rows, position);\n        _position[0] = pos[0];\n        _position[1] = pos[1];\n        return _this;\n    };\n\n    /**\n     * Walk in a given direction based on the current position.\n     *\n     * @param {Array} direction - The direction you want to go. (It's the position relative to the current position)\n     * @returns {gridl} The same gridl instance.\n     */\n    this.walk = function (direction) {\n        var pos = _walk(_columns, _rows, _position, direction);\n        _position[0] = pos[0];\n        _position[1] = pos[1];\n        return _this;\n    };\n\n    /**\n     * Get the current position.\n     *\n     * @returns {Array} The current position array [column, row].\n     */\n    this.position = function () {\n        return [_position[0], _position[1]];\n    };\n\n    /**\n     * Map over all cells. It's the equivalent of Array.map just for the grid.\n     *\n     * @param {iteratorCallback} callback - The callback function that is called on each cell.<br><code>function(cell, position, gridlInstance) { return ... }</code>\n     * @returns {gridl} A new gridl instance.\n     */\n    this.map = function (callback) {\n        var newData = _data.map(function (v, i) {\n            return callback(v, _index2pos(i, _columns), _this);\n        });\n        return new gridl(_toArray2D(newData, _columns));\n    };\n\n    /**\n     * Iterate over all cells. It's the equivalent of Array.forEach just for the grid.\n     *\n     * @param {iteratorCallback} callback - The callback function is called for each cell.<br><code>function(cell, position, gridlInstance) { return ... }</code>\n     * @returns {gridl} The same gridl instance.\n     */\n    this.forEach = function (callback) {\n        _data.forEach(function (v, i) {\n            return callback(v, _index2pos(i, _columns), _this);\n        });\n        return _this;\n    };\n\n    /**\n     * Applies a function against an accumulator and each element in the grid to reduce it to a single value.\n     *\n     * @param {reducerCallback} callback - The callback function that is executed on each cell.<br><code>function(accumulator, cell, position, gridlInstance) { return ... }</code>\n     * @param {*} [initialValue=undefined] - Value to use as the first argument to the first call of the <code>callback</code>. If no initial value is supplied, the first element in the grid will be used.\n     * @returns {*} The value that results from the reduction.\n     */\n    this.reduce = function (callback, initialValue) {\n        var _this2 = this;\n\n        var reducer = function reducer(acc, v, i) {\n            return callback(acc, v, _index2pos(i, _columns), _this2);\n        };\n        return arguments.length === 1 ? _data.reduce(reducer) : _data.reduce(reducer, initialValue);\n    };\n\n    /**\n     * Applies a function against an accumulator and each element in the area at a given position to reduce it to a single value.\n     *\n     * @param {number[][]} position - The position of the area within the grid.\n     * @param {number[][]} size - The size of the area within the grid.\n     * @param {reducerCallback} callback - The callback function that is executed on each cell within the grid.\n     * @param {*} [initialValue=undefined] - Value to use as the first argument to the first call of the <code>callback</code>. If no initial value is supplied, the first element in the grid will be used.\n     * @returns {*} The value that results from the reduction.\n     */\n    this.reduceAreaAt = function (position, size, callback, initialValue) {\n        return _reduceAreaAt(this, _columns, _rows, position, size, callback, initialValue, arguments.length === 1);\n    };\n\n    /**\n     * Applies a function against an accumulator and each element in the area at the current position to reduce it to a single value.\n     *\n     * @param {number[][]} size - The size of the area within the grid.\n     * @param {reducerCallback} callback - The callback function that is executed on each cell within the grid.\n     * @param {*} [initialValue=undefined] - Value to use as the first argument to the first call of the <code>callback</code>. If no initial value is supplied, the first element in the grid will be used.\n     * @returns {*} The value that results from the reduction.\n     */\n    this.reduceArea = function (size, callback, initialValue) {\n        return _reduceAreaAt(this, _columns, _rows, _position, size, callback, initialValue, arguments.length === 1);\n    };\n\n    /**\n     * Make a clone of the current gridl instance.\n     *\n     * @returns {gridl} A new gridl instance.\n     */\n    this.clone = function () {\n        return new gridl(_toArray2D(_data, _columns)).goto(_position);\n    };\n\n    /**\n     * Get the values of all adjacent cells at a given position.\n     *\n     * @param {number[]} position - The position of the cell of which you want to know its adjacent cells.\n     * @param {number[][]} [adjacence = [adjacents.ALL]{@link adjacences}] - A list of positions relative to the given position. These positions are considered as the adjacents.\n     * @param {boolean} [includeOutsideValues = false] - If <code>false</code>, adjacent cells that are outside the grid will be ignored, if <code>true</code>, <code>undefined</code> will be returned for them.\n     * @returns {Array.<*>} The values of the adjacent cells.\n     */\n    this.adjacentCellsAt = function (position) {\n        var adjacence = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : adjacences.ALL;\n        var includeOutsideValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n\n        var gridSize = !includeOutsideValues && [_columns, _rows];\n        var grid = _toArray2D(_data, _columns);\n        return _adjacentCells(grid, position, adjacence, gridSize);\n    };\n\n    /**\n     * Get the values of all adjacent cells at the current position.<br>\n     * The current position can be defined by [goto(position)]{@link gridl#goto} or [walk(direction)]{@link gridl#walk}.\n     *\n     * @param {number[][]} [adjacence = [adjacents.ALL]{@link adjacences}] - A list of positions relative to the given position. These positions are considered as the adjacents.\n     * @param {boolean} [includeOutsideValues = false] - If <code>false</code>, adjacent cells that are outside the grid will be ignored, if <code>true</code>, <code>undefined</code> will be returned for them.\n     * @returns {Array.<*>} The values of the adjacent cells.\n     */\n    this.adjacentCells = function () {\n        var adjacence = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : adjacences.ALL;\n        var includeOutsideValues = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n        var gridSize = !includeOutsideValues && [_columns, _rows];\n        var grid = _toArray2D(_data, _columns);\n        return _adjacentCells(grid, _position, adjacence, gridSize);\n    };\n\n    /**\n     * Exports all entries as an one dimensional array.\n     *\n     * @returns {Array.<*>}\n     */\n    this.list = function () {\n        return [].concat(_toConsumableArray(_data));\n    };\n\n    return this;\n}\n\n/**\n * Predefined directions you can walk in.<br>\n * Use it in combination with [walk(direction)]{@link gridl#walk}.\n *\n * @type {Object}\n * @property {Array.<number>} UP - one step up\n * @property {Array.<number>} UP_LEFT - one step left, one step up\n * @property {Array.<number>} UP_RIGHT - one step right, one step up\n * @property {Array.<number>} RIGHT - one step right\n * @property {Array.<number>} LEFT - one step left\n * @property {Array.<number>} DOWN - one step down\n * @property {Array.<number>} DOWN_LEFT - one step left, one step down\n * @property {Array.<number>} DOWN_RIGHT - one step right, one step down\n */\nvar directions = exports.directions = Object.freeze({\n    UP: Object.freeze([0, -1]),\n    UP_RIGHT: Object.freeze([1, -1]),\n    RIGHT: Object.freeze([1, 0]),\n    DOWN_RIGHT: Object.freeze([1, 1]),\n    DOWN: Object.freeze([0, 1]),\n    DOWN_LEFT: Object.freeze([-1, 1]),\n    LEFT: Object.freeze([-1, 0]),\n    UP_LEFT: Object.freeze([-1, -1])\n});\n\n/**\n * Predefined lists of adjacent positions relative to a certain position.\n *\n * @type {Object}\n * @property {number[][]} ALL - all direct adjacent positions (orthogonal + diagonal) in the order: left to right, top to bottom\n * @property {number[][]} ALL_CW - all direct adjacent positions (orthogonal + diagonal) in clockwise order\n * @property {number[][]} ALL_CCW - all direct adjacent positions (orthogonal + diagonal) in counterclockwise order\n * @property {number[][]} ORTHOGONAL - all orthogonal adjacent positions in the order: left to right, top to bottom\n * @property {number[][]} ORTHOGONAL_CW - all orthogonal adjacent positions in clockwise order\n * @property {number[][]} ORTHOGONAL_CCW - all orthogonal adjacent positions in counterclockwise order\n * @property {number[][]} DIAGONAL - all diagonal adjacent positions in the order: left to right, top to bottom\n * @property {number[][]} DIAGONAL_CW - all diagonal adjacent positions in clockwise order\n * @property {number[][]} DIAGONAL_CCW - all diagonal adjacent positions in counterclockwise order\n */\nvar adjacences = exports.adjacences = Object.freeze({\n    ALL: Object.freeze([directions.UP_LEFT, directions.UP, directions.UP_RIGHT, directions.LEFT, directions.RIGHT, directions.DOWN_LEFT, directions.DOWN, directions.DOWN_RIGHT]),\n    ALL_CW: Object.freeze([directions.UP, directions.UP_RIGHT, directions.RIGHT, directions.DOWN_RIGHT, directions.DOWN, directions.DOWN_LEFT, directions.LEFT, directions.UP_LEFT]),\n    ALL_CCW: Object.freeze([directions.UP, directions.UP_LEFT, directions.LEFT, directions.DOWN_LEFT, directions.DOWN, directions.DOWN_RIGHT, directions.RIGHT, directions.UP_RIGHT]),\n    ORTHOGONAL: Object.freeze([directions.UP, directions.LEFT, directions.RIGHT, directions.DOWN]),\n    ORTHOGONAL_CW: Object.freeze([directions.UP, directions.RIGHT, directions.DOWN, directions.LEFT]),\n    ORTHOGONAL_CCW: Object.freeze([directions.UP, directions.LEFT, directions.DOWN, directions.RIGHT]),\n    DIAGONAL: Object.freeze([directions.UP_LEFT, directions.UP_RIGHT, directions.DOWN_LEFT, directions.DOWN_RIGHT]),\n    DIAGONAL_CW: Object.freeze([directions.UP_RIGHT, directions.DOWN_RIGHT, directions.DOWN_LEFT, directions.UP_LEFT]),\n    DIAGONAL_CCW: Object.freeze([directions.UP_LEFT, directions.DOWN_LEFT, directions.DOWN_RIGHT, directions.UP_RIGHT])\n});\n\n/**\n * Create a two dimensional grid array.\n *\n * @param {number} columns - The number of columns.\n * @param {number} rows - The number of rows.\n * @param {Function} callback - The generator function that is called on each cell.\n * @returns {Array.<Array.<*>>} The new grid array.\n */\nfunction makeGrid(columns, rows) {\n    var callback = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : function () {\n        return null;\n    };\n\n    var parsedColumns = parseInt(columns);\n    var parsedRows = parseInt(rows);\n    if (parsedColumns < 1 || isNaN(parsedColumns)) {\n        throw new Error('You need to specify at least one column. Given: ' + columns);\n    }\n    if (parsedRows < 1 || isNaN(parsedRows)) {\n        throw new Error('You need to specify at least one row. Given: ' + rows);\n    }\n    return Array.from({ length: parsedRows }, function (vr, row) {\n        return Array.from({ length: parsedColumns }, function (vc, column) {\n            return callback({ column: column, row: row });\n        });\n    });\n}\n\n/**\n * Generate a one-dimensional array that can be a single row or column.\n *\n * @param {number} length - The length of the array.\n * @param {Function} callback - The generator callback function that is called on each element.\n * @returns {Array.<*>}\n */\nfunction makeList(length) {\n    var callback = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : function () {\n        return null;\n    };\n\n    var parsedLength = parseInt(length);\n    if (parsedLength < 1 || isNaN(parsedLength)) {\n        throw new Error('Trying to make a list with an invalid length. Given: ' + length);\n    }\n    return Array.from({ length: parsedLength }, function (v, i) {\n        return callback(i);\n    });\n}\n\n/**\n * Generate a gridl instance from scratch by specifying the number of rows and columns and fill it with values.\n *\n * @param {number} numColumns - The number of columns.\n * @param {number} numRows - The number of rows.\n * @param {Function} callback - The generator function that is called for each cell. The returned value is going to be the value of the cell.\n * @returns {gridl} A new gridl instance\n */\nfunction make(numColumns, numRows, callback) {\n    return new gridl(makeGrid(numColumns, numRows, callback));\n}\n\n/**\n * Creates a new gridl instance.<br>\n * <br>\n * This is exported as the default function. It serves as a wrapper around gridl so that you don't have to use the <code>`new`</code>\n * keyword each time. So instead of saying `<code>new gridl(data)</code>` you can just say `<code>gridl(data)</code>`.\n * That's the only reason for gridlFactory.<br>\n * <br>\n * Please don't care too much about the difference between gridl and gridlFactory. Just use it as `<code>gridl(data)</code>`.\n *\n * @constructor\n * @param {Array.<Array.<*>>} data - A two dimensional grid array. Every row needs to have the same length.\n * @returns {gridl}\n */\nvar gridlFactory = function gridlFactory(data) {\n    return new gridl(data);\n};\ngridlFactory.adjacences = adjacences;\ngridlFactory.directions = directions;\ngridlFactory.make = make;\ngridlFactory.makeGrid = makeGrid;\ngridlFactory.makeList = makeList;\n\nexports.default = gridlFactory;\n\n/***/ })\n/******/ ]);\n});\n\n\n// WEBPACK FOOTER //\n// gridl.min.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 7204d0b05b1ce076b999","function _isValidGridArray(data) {\n    if (!Array.isArray(data)) {\n        throw new Error('Trying to import data that is not an array.');\n    }\n    data.forEach((row, i) => {\n        if (!Array.isArray(row)) {\n            throw new Error('Trying to import data that is not an array.');\n        }\n        if (i > 0 && data[i - 1].length !== row.length) {\n            throw new Error('Trying to import data with different row lengths.');\n        }\n        if (row.length < 1) {\n            throw new Error('Trying to import grid without any columns. You need to provide at least one column.');\n        }\n    });\n}\n\nconst _isValidPositionFormat = pos => {\n    if (!Array.isArray(pos) || pos.length !== 2) {\n        return false;\n    }\n    return (Number.isSafeInteger(pos[0]) && Number.isSafeInteger(pos[1]));\n};\n\nconst _index2pos = (index, columns) => [index % columns, Math.floor(index / columns)];\n\nconst _pos2index = (position, columns) => position && position[0] + position[1] * columns;\n\nconst _toArray2D = (array1D, columns) => array1D.reduce((res, cell, index) => {\n    const pos = _index2pos(index, columns);\n    if (!res[pos[1]]) {\n        res[pos[1]] = [];\n    }\n    res[pos[1]][pos[0]] = cell;\n    return res;\n}, []);\n\nconst _flatten = array2D => array2D.reduce((res, row) => [...res, ...row], []);\n\nconst _getColumn = (data, x) => {\n    if (x >= 0 && x < data[0].length) {\n        return data.map(row => row[x]);\n    }\n};\n\nconst _getRow = (data, y) => data[y];\n\nconst _addPositions = (p1, p2) => [\n    p1[0] + p2[0],\n    p1[1] + p2[1],\n];\n\nconst _subtractPositions = (p1, p2) => [\n    p1[0] - p2[0],\n    p1[1] - p2[1],\n];\n\nconst _limit = (v, min, max) => Math.max(Math.min(v, max), min);\n\nconst _swap = (arr, i1, i2) => {\n    const tmp = arr[i1];\n    arr[i1] = arr[i2];\n    arr[i2] = tmp;\n};\n\nconst _move = (data, fromIndex, toIndex) => {\n    const cell = data[fromIndex];\n    data.splice(fromIndex, 1);\n    data.splice(toIndex, 0, cell);\n    return data;\n};\n\nconst _isNotInArea = (areaSize, position) => (\n    position[0] < 0 || position[0] >= areaSize[0] ||\n    position[1] < 0 || position[1] >= areaSize[1]\n);\n\nfunction _getValueAt(_data, columns, pos) {\n    const index = _pos2index(pos, columns);\n    if (isNaN(index)) {\n        return;\n    }\n    return _data[index];\n}\n\nfunction _setValueAt(api, _data, columns, rows, pos, value) {\n    if (_isNotInArea([columns, rows], pos)) {\n        return api;\n    }\n    const index = _pos2index(pos, columns);\n    if (!isNaN(index)) {\n        _data[index] = value;\n    }\n    return api;\n}\n\nfunction _setAreaAt(api, columns, rows, position, area, anchor = [0,0]) {\n    const pos = _subtractPositions(position, anchor);\n    area.forEach((row, r) => {\n        const targetPos = [0, r + pos[1]];\n        if (targetPos[1] >= rows) {\n            return;\n        }\n        row.forEach((cell, c) => {\n            targetPos[0] = c + pos[0];\n            if (targetPos[0] >= columns) {\n                return;\n            }\n            api.setValueAt(targetPos, cell);\n        });\n    });\n    return api;\n}\n\nfunction _getAreaAt(api, columns, rows, position, size, anchor = [0,0]) {\n    const posTmp = _subtractPositions(position, anchor);\n    const end = [\n        Math.min(posTmp[0] + size[0], columns),\n        Math.min(posTmp[1] + size[1], rows),\n    ];\n    const pos = [\n        Math.max(0, posTmp[0]),\n        Math.max(0, posTmp[1]),\n    ];\n    const area = [];\n    for (let r = pos[1]; r < end[1]; r++) {\n        const rArea = r - pos[1];\n        if (!area[rArea]) {\n            area[rArea] = [];\n        }\n        for (let c = pos[0]; c < end[0]; c++) {\n            const cArea = c - pos[0];\n            area[rArea][cArea] = api.valueAt([c, r]);\n        }\n    }\n    return area;\n}\n\nfunction _find(columns, data, callback) {\n    const index = data.findIndex(callback);\n    return (index >= 0) ? _index2pos(index, columns) : undefined;\n}\n\nfunction _findInArea(api, columns, pos, size, callback) {\n    const area = api.getAreaAt(pos, size);\n    const flat = _flatten(area);\n    const areaIndex = flat.findIndex((v, i) => callback(v, _index2pos(i, columns), api));\n    if (areaIndex >= 0) {\n        const areaColumns = area[0].length;\n        const posInArea = _index2pos(areaIndex, areaColumns);\n        return [\n           pos[0] + posInArea[0],\n           pos[1] + posInArea[1],\n        ];\n    }\n}\n\nfunction _checkAreaFitsAt(columns, rows, position, area, anchor = [0,0]) {\n    const pos = _subtractPositions(position, anchor);\n    const fitsHorizontally = pos[0] >= 0 && pos[0] + area[0].length <= columns;\n    const fitsVertically = pos[1] >= 0 && pos[1] + area.length <= rows;\n    return fitsHorizontally && fitsVertically;\n}\n\nfunction _goto(columns, rows, position) {\n    if (!Array.isArray(position)) {\n        throw new Error(`Trying to go to an invalid position. Given: ${position}`);\n    }\n    // if (_isNotInArea([columns, rows], position)) {\n    //     throw new Error(`Trying to go to an invalid position. Given: ${position}`);\n    // }\n    return position;\n}\n\nfunction _walk(columns, rows, startPos, direction) {\n    const targetPos = _addPositions(startPos, direction);\n    if (_isNotInArea([columns, rows], targetPos)) {\n        throw new Error(`Trying to walk to an invalid position. Position: ${targetPos}`);\n    }\n    return targetPos;\n}\n\nfunction _moveCell(data, columns, rows, from, to) {\n    const fromIndex = _pos2index(from, columns);\n    const size = [columns, rows];\n    if (isNaN(fromIndex) || _isNotInArea(size, from)) {\n        throw new Error(`Trying to move cell from an invalid position. Given: [${from}]`);\n    }\n    const toIndex = _pos2index(to, columns);\n    if (isNaN(toIndex) || _isNotInArea(size, to)) {\n        throw new Error(`Trying to move cell to an invalid position. Given: [${to}]`);\n    }\n    _move(data, fromIndex, toIndex);\n}\n\nfunction _moveRow(_grid, _columns, _rows, yFrom, yTo) {\n    if (yFrom < 0 || yFrom >= _rows) {\n        throw new Error(`Trying to move row from an invalid position. Given: ${yFrom}`);\n    }\n    if (yTo < 0 || yTo >= _rows) {\n        throw new Error(`Trying to move row to an invalid position. Given: ${yTo}`);\n    }\n    return _flatten(_move(_grid, yFrom, yTo));\n}\n\nfunction _moveColumn(grid, columns, rows, xFrom, xTo) {\n    if (xFrom < 0 || xFrom >= columns) {\n        throw new Error(`Trying to move column from an invalid position. Given: ${xFrom}`);\n    }\n    if (xTo < 0 || xTo >= columns) {\n        throw new Error(`Trying to move column to an invalid position. Given: ${xTo}`);\n    }\n    const newGrid = grid.map(row => _move(row, xFrom, xTo));\n    return _flatten(newGrid);\n}\n\nfunction _addRowAt(grid, columns, rows, row, y) {\n    if (y < 0 || y > rows) {\n        throw new Error(`Trying to add row at an invalid position. Given: ${y}`);\n    }\n    if (row.length !== columns) {\n        throw new Error(\n            `Trying to add a row that contains an invalid amount of cells. Expected: ${columns}, Given: ${row.length}`\n        );\n    }\n    grid.splice(y, 0, row);\n    return grid;\n}\n\nfunction _addColumnAt(grid, columns, rows, column, x) {\n    if (x < 0 || x > columns) {\n        throw new Error(`Trying to add column at an invalid position. Given: ${x}`);\n    }\n    if (column.length !== rows) {\n        throw new Error(\n            `Trying to add a column that contains an invalid amount of cells. Expected: ${rows}, Given: ${column.length}`\n        );\n    }\n    return grid.map((row, i) => {\n        row.splice(x, 0, column[i]);\n        return row;\n    });\n}\n\nfunction _removeRowAt(grid, rows, y) {\n    if (y < 0 || y >= rows) {\n        throw new Error(`Trying to remove a row at an invalid position. Given: ${y}`);\n    }\n    if (rows <= 1) {\n        throw new Error('Cannot remove row because the grid would be empty after it.');\n    }\n    grid.splice(y, 1);\n    return grid;\n}\n\nfunction _removeColumnAt(grid, columns, x) {\n    if (x < 0 || x >= columns) {\n        throw new Error(`Trying to remove a column at an invalid position. Given: ${x}`);\n    }\n    if (columns <= 1) {\n        throw new Error('Cannot remove column because the grid would be empty after it.');\n    }\n    return grid.map(row => row.filter((v, c) => c !== x));\n}\n\nfunction _clip(grid, _columns, _rows, position, size) {\n    if (position[0] < 0 || position[0] >= _columns || position[1] < 0 || position[1] >= _rows) {\n        throw new Error(`Trying to clip data at an invalid position. Given: ${position}`);\n    }\n    const endPoint = _addPositions(position, size);\n    return grid\n        .filter((row, r) => r >= position[1] && r < endPoint[1])\n        .map(row => row.filter((cell, c) => c >= position[0] && c < endPoint[0]));\n}\n\nfunction _swapCells(api, pos1, pos2) {\n    const size = api.size();\n    if (_isNotInArea(size, pos1) || _isNotInArea(size, pos2)) {\n        throw new Error('Trying to swap cells with an invalid position.');\n    }\n    const tmp = api.valueAt(pos1);\n    api.setValueAt(pos1, api.valueAt(pos2));\n    api.setValueAt(pos2, tmp);\n    return api;\n}\n\nfunction _swapRows(grid, rows, y1, y2) {\n    if (y1 < 0 || y1 >= rows) {\n        throw new Error(`Trying to swap rows from an invalid position. Given: ${y1}`);\n    }\n    if (y2 < 0 || y2 >= rows) {\n        throw new Error(`Trying to swap rows to an invalid position. Given: ${y2}`);\n    }\n    _swap(grid, y1, y2);\n    return _flatten(grid);\n}\n\nfunction _swapColumns(grid, columns, x1, x2) {\n    if (x1 < 0 || x1 >= columns) {\n        throw new Error(`Trying to swap columns from an invalid position. Given: ${x1}`);\n    }\n    if (x2 < 0 || x2 >= columns) {\n        throw new Error(`Trying to swap columns to an invalid position. Given: ${x2}`);\n    }\n    grid.map(row => {\n        _swap(row, x1, x2);\n        return row;\n    });\n    return _flatten(grid);\n}\n\nfunction _rotate(grid, columns, steps) {\n    const mod = steps % 4;\n    const option = mod < 0 ? mod + 4 : mod;\n    switch (option) {\n        case 0:\n            return grid;\n        case 1:\n            return Array.from({ length: columns }, (v, i) => _getColumn(grid, i).reverse());\n        case 2:\n            return grid.reverse().map((row, r) => row.reverse());\n        case 3:\n            return Array.from({ length: columns }, (v, i) => _getColumn(grid, columns - 1 - i));\n        default:\n            throw new Error(`Trying to rotate the grid with an invalid steps parameter. Given: ${steps}`);\n    }\n}\n\nfunction _mirror(arr, index) {\n    if (index === undefined) {\n        return arr.reverse();\n    }\n    const limitedIdx = _limit(index, 0, arr.length - 1);\n    const left = arr.filter((v, i) => i < limitedIdx);\n    const right = arr.filter((v, i) => i > limitedIdx);\n    return [\n        ...right.reverse(),\n        arr[limitedIdx],\n        ...left.reverse(),\n    ];\n}\n\nfunction _adjacentCells(grid, position, adjacence, gridSize = null) {\n    return adjacence.reduce((res, direction) => {\n        const absPos = _addPositions(position, direction);\n        const value = grid && grid[absPos[1]] && grid[absPos[1]][absPos[0]];\n        if (gridSize) {\n            return _isNotInArea(gridSize, absPos) ? res : [...res, value];\n        }\n        else {\n            return [...res, value];\n        }\n    }, []);\n}\n\nfunction _reduceAreaAt(api, columns, rows, position, size, callback, initialValue, hasInitialValue) {\n    if (!_isValidPositionFormat(position)) {\n        throw new Error('Trying to reduce an area at an invalid position.');\n    }\n    if (!_isValidPositionFormat(size)) {\n        throw new Error('Trying to reduce an area with invalid size.');\n    }\n    const reducer = (acc, v, i) => {\n        const local = _index2pos(i, size[0]);\n        const global = _addPositions(local, position);\n        return callback(acc, v, global, api);\n    };\n    const flattenedArea = _flatten(_getAreaAt(api, columns, rows, position, size));\n    return hasInitialValue ? flattenedArea.reduce(reducer) : flattenedArea.reduce(reducer, initialValue);\n}\n\n/**\n * Generates a new gridl instance.\n *\n * @constructor\n * @param {Array} data - A two-dimsensional grid array. Every row needs to have the same length.\n * @returns {gridl} The new gridl instance.\n */\nfunction gridl(data) {\n\n    /**\n     * @callback iteratorCallback\n     * @param {*} cell - The value of the current cell.\n     * @param {Array.<number>} position - The current position.\n     * @param {gridl} gridlInstance - The current gridl instance.\n     */\n\n    /**\n     * @callback reducerCallback\n     * @param {*} accumulator - The accumulator accumulates the callback's return values; it is the accumulated value previously returned in the last invocation of the callback, or initialValue, if supplied.\n     * @param {*} cell - The value of the current cell.\n     * @param {Array.<number>} position - The current position.\n     * @param {gridl} gridlInstance - The current gridl instance.\n     */\n\n    _isValidGridArray(data);\n\n    let _rows = data.length;\n    let _columns = data[0].length;\n    let _data = _flatten(data);\n    let _position = [0,0];\n\n    /**\n     * get the number of columns.\n     */\n    this.numColumns = () => _columns;\n\n    /**\n     * Get the number of rows.\n     * @returns {number}\n     */\n    this.numRows = () => _rows;\n\n    /**\n     * Get the current size of the grid.\n     *\n     * @returns {number[]}\n     */\n    this.size = () => [_columns, _rows];\n\n    /**\n     * Set the value at the current position. You can also set the cell to <code>undefined</code>\n     * The current position can be defined by [goto(position)]{@link gridl#goto} or [walk(direction)]{@link gridl#walk}.\n     *\n     * @param {*} value - The value the cell should have.\n     */\n    this.setValue = value => _setValueAt(this, _data, _columns, _rows, _position, value);\n\n    /**\n     * Get or set the value at the current position.<br>\n     * It returns the cell's value if you provide no value and sets it if you do provide a value.<br>\n     * To explicitly set the value to <code>undefined</code> use [setValue()]{@link gridl#setValue}.\n     *\n     * @param {*} value - The value you want to set or <code>undefined</code> if you want to get the value.\n     * @returns {*} The cell's value or the gridl instance if you use it as a setter.\n     */\n    this.value = value => value === undefined ? _getValueAt(_data, _columns, _position) : _setValueAt(this, _data, _columns, _rows, _position, value);\n\n    /**\n     * Set the value at a certain position. You can also set the cell to <code>undefined</code>\n     *\n     * @param {Array.<number>} pos - The position where you want to set the value.\n     * @param {*} value - The value you want to set.\n     * @returns {gridl} The same gridl instance.\n     */\n    this.setValueAt = (pos, value) => _setValueAt(this, _data, _columns, _rows, pos, value);\n\n    /**\n     * Get or set the value at a certain position.<br>\n     * It returns the cell's value if you provide no value and sets it if you do provide a value.<br>\n     * To explicitly set the value to <code>undefined</code> use [setValueAt()]{@link gridl#setValueAt}.\n     *\n     * @param {Array.<number>} pos - The position where you want to set or get the value.\n     * @param {*} value - The value you want to set or <code>undefined</code> if you want to get the value.\n     * @returns {*} The cell's value or the the same gridl instance if you use it as a setter.\n     */\n    this.valueAt = (pos, value) => value === undefined ? _getValueAt(_data, _columns, pos) : _setValueAt(this, _data, _columns, _rows, pos, value);\n\n    /**\n     * Move a cell from one position to another.\n     *\n     * @param {Array} from - The position of the cell that you want to move.\n     * @param {Array} to - The position where the cell should be moved.\n     * @returns {gridl} - The current gridl instance.\n     */\n    this.moveCell = (from, to) => {\n        _moveCell(_data, _columns, _rows, from, to);\n        return this;\n    };\n\n    /**\n     * Move the current cell to an absolute position.\n     * The current position can be defined by [goto(position)]{@link gridl#goto} or [walk(direction)]{@link gridl#walk}.\n     *\n     * @param {Array} to - The position where the cell should be moved.\n     * @returns {gridl}\n     */\n    this.moveAbs = to => {\n        _moveCell(_data, _columns, _rows, _position, to);\n        return this;\n    };\n\n    /**\n     * Move the current cell from the current position in a certain direction.\n     * The current position can be defined by [goto(position)]{@link gridl#goto} or [walk(direction)]{@link gridl#walk}.\n     *\n     * @param {Array} direction - The direction in which to move from the current position.\n     * @returns {gridl} The current gridl instance.\n     */\n    this.moveRel = direction => this.moveCell(_position, _addPositions(_position, direction));\n\n    /**\n     * Move a row to a certain position.\n     *\n     * @param {number} yFrom - The position on the y-axis of the row you want to move.\n     * @param {number} yTo - The position on the y-axis of where the row should be moved to.\n     * @returns {gridl} The current gridl instance.\n     */\n    this.moveRow = (yFrom, yTo) => {\n        _data = _moveRow(this.data(), _columns, _rows, yFrom, yTo);\n        return this;\n    };\n\n    /**\n     * Move a column to a certain position.\n     *\n     * @param {number} xFrom - The position on the x-axis of the column you want to move.\n     * @param {number} xTo - The position on the x-axis of where the column should be moved.\n     * @returns {gridl}\n     */\n    this.moveColumn = (xFrom, xTo) => {\n        _data = _moveColumn(this.data(), _columns, _rows, xFrom, xTo);\n        return this;\n    };\n\n    /**\n     * Get the column at a certain x-position\n     *\n     * @param {number} x - The x-position of the column you want to get.\n     * @returns {Array.<*>}\n     */\n    this.column = x => _getColumn(this.data(), x);\n\n    /**\n     * Get the row at a certain y-position\n     *\n     * @param {number} y - The y-position of the row you want to get.\n     * @returns {Array.<*>}\n     */\n    this.row = y => _getRow(this.data(), y);\n\n    /**\n     * Add a row at a certain y-position. This changes the size of the grid.\n     *\n     * @param {Array.<*>} row - The row you want to add as an one-dimensional array.\n     * @param {number} y - The y-position of where you want to add the row.\n     * @returns {gridl} The same gridl instance.\n     */\n    this.addRow = (row, y) => {\n        const grid = _addRowAt(this.data(), _columns, _rows, row, y);\n        _data = _flatten(grid);\n        _rows = grid.length;\n        return this;\n    };\n\n    /**\n     * Add a column at a certain x-position. This changes the size of the grid.\n     *\n     * @param {Array.<*>} column - The column you want to add as an one-dimensional array.\n     * @param {number} x - The x-position of where you want to add the column.\n     * @returns {gridl} The same gridl instance.\n     */\n    this.addColumn = (column, x) => {\n        const grid = _addColumnAt(this.data(), _columns, _rows, column, x);\n        _data = _flatten(grid);\n        _columns = grid[0].length;\n        return this;\n    };\n\n    /**\n     * Remove a row at a certain y-position. This changes the size of the grid.\n     *\n     * @param {number} y - The y-position of the row you want to remove.\n     * @returns {gridl} The same gridl instance.\n     */\n    this.removeRow = y => {\n        const grid = _removeRowAt(this.data(), _rows, y);\n        _data = _flatten(grid);\n        _rows = grid.length;\n        return this;\n    };\n\n    /**\n     * Remove a column at a certain x-position. This changes the size of the grid.\n     *\n     * @param {number} x - The x-position of the column you want to remove.\n     * @returns {gridl} The same gridl instance.\n     */\n    this.removeColumn = x => {\n        const grid = _removeColumnAt(this.data(), _columns, x);\n        _data = _flatten(grid);\n        _columns = grid[0].length;\n        return this;\n    };\n\n    /**\n     * Clip an area out of the current grid. It removes all cells that are not inside the given area.\n     *\n     * @param {Array.<number>} position - The position the area.\n     * @param {Array.<number>} size - The size of the area.\n     * @returns {gridl} The same gridl instance.\n     */\n    this.clipAt = (position, size) => {\n        const grid = _clip(this.data(), _columns, _rows, position, size);\n        _data = _flatten(grid);\n        _rows = grid.length;\n        _columns = grid[0].length;\n        return this;\n    };\n\n    /**\n     * Clip an area out of the current grid at the current position. It removes all cells that are not inside the given area.<br>\n     * The current position can be defined by [goto(position)]{@link gridl#goto} or [walk(direction)]{@link gridl#walk}.\n     *\n     * @param {Array.<number>} size - The size of the area.\n     * @returns {gridl} The same gridl instance.\n     */\n    this.clip = size => this.clipAt(_position, size);\n\n    /**\n     * Swap the values of two cells.\n     *\n     * @param {Array.<number>} position1 - The position of the first cell.\n     * @param {Array.<number>} position2 - The position of the second cell.\n     * @returns {gridl} The same gridl instance.\n     */\n    this.swapCells = (position1, position2) => _swapCells(this, position1, position2);\n\n    /**\n     * Swaps the values of the cell at the current position and another cell.<br>\n     * The current position can be defined by [goto(position)]{@link gridl#goto} or [walk(direction)]{@link gridl#walk}.\n     *\n     * @param {Array.<number>} position - The position of the first cell.\n     * @returns {gridl} The same gridl instance.\n     */\n    this.swapCell = position => _swapCells(this, _position, position);\n\n    /**\n     * Swaps the values of two rows.\n     *\n     * @param {Array.<number>} y1 - The y-position of the first row.\n     * @param {Array.<number>} y2 - The y-position of the second row.\n     * @returns {gridl} The same gridl instance.\n     */\n    this.swapRows = (y1, y2) => {\n        _data = _swapRows(this.data(), _rows, y1, y2);\n        return this;\n    };\n\n    /**\n     * Swaps the values of two columns.\n     *\n     * @param {Array.<number>} x1 - The x-position of the first column.\n     * @param {Array.<number>} x2 - The x-position of the second column.\n     * @returns {gridl} The same gridl instance.\n     */\n    this.swapColumns = (x1, x2) => {\n        _data = _swapColumns(this.data(), _columns, x1, x2);\n        return this;\n    };\n\n    /**\n     * Overwrite the values of a given area at a certain position.\n     *\n     * @param {Array.<number>} position - The position of the area.\n     * @param {Array.<number>} area - The area itself as two-dimensional grid array.\n     * @param {Array.<number>} [anchor = [0, 0]] - The center of area.\n     * @returns {gridl} The same gridl instance.\n     */\n    this.setAreaAt = (position, area, anchor) => _setAreaAt(this, _columns, _rows, position, area, anchor);\n\n    /**\n     * Overwrite the values of a given area at the current position.<br>\n     * The current position can be defined by [goto(position)]{@link gridl#goto} or [walk(direction)]{@link gridl#walk}.\n     *\n     * @param {Array.<number>} area - The area itself as two-dimensional grid array.\n     * @param {Array.<number>} [anchor = [0, 0]] - The center of area.\n     * @returns {gridl} The same gridl instance.\n     */\n    this.setArea = (area, anchor) => _setAreaAt(this, _columns, _rows, _position, area, anchor);\n\n    /**\n     * Exports the data grid array of a given array at the given position.\n     *\n     * @param {Array.<number>} position - The position of the area.\n     * @param {Array.<number>} size - The size fo the area as a two-dimensional grid array.\n     * @param {Array.<number>} [anchor = [0, 0]] - The center of area.\n     * @returns {number[][]}\n     */\n    this.getAreaAt = (position, size, anchor) => _getAreaAt(this, _columns, _rows, position, size, anchor);\n\n    /**\n     * Exports the data grid array of a given array at the current position.<br>\n     * The current position can be defined by [goto(position)]{@link gridl#goto} or [walk(direction)]{@link gridl#walk}.\n     *\n     * @param {Array.<number>} size - The size fo the area as a two-dimensional grid array.\n     * @param {Array.<number>} [anchor = [0, 0]] - The center of area.\n     * @returns {number[][]}\n     */\n    this.getArea = (size, anchor) => _getAreaAt(this, _columns, _rows, _position, size, anchor);\n\n    /**\n     * Check if a given area would fit inside the grid at a given position.\n     *\n     * @param {number[]} position - The position where the area should be placed.\n     * @param {Array.<Array.<*>>} area - The area itself as a two-dimensional grid array\n     * @param {number[]} [anchor = [0, 0]] - The center of area.\n     * @returns {boolean} Whether the area fits or not.\n     */\n    this.areaFitsAt = (position, area, anchor) => _checkAreaFitsAt(_columns, _rows, position, area, anchor);\n\n    /**\n     * Check if a given area would fit inside the grid at the current position.<br>\n     * The current position can be defined by [goto(position)]{@link gridl#goto} or [walk(direction)]{@link gridl#walk}.\n     *\n     * @param {Array.<Array.<*>>} area - The area itself as a two-dimensional grid array\n     * @param {number[]} [anchor = [0, 0]] - The center of area.\n     * @returns {boolean} Whether the area fits or not.\n     */\n    this.areaFits = (area, anchor) => _checkAreaFitsAt(_columns, _rows, _position, area, anchor);\n\n    /**\n     * Find the first occurrence of an element within the entire grid.\n     *\n     * @param {iteratorCallback} callback - The callback function that is called on each element. Should return true if the element is found or false if not.\n     * @returns {(Array.<number>|undefined)} The position of the first element that is found or <code>undefined</code> if nothing was found.\n     */\n    this.find = callback => _find(_columns, _data, (v, i) => callback(v, _index2pos(i, _columns), this));\n\n    /**\n     * Find the first occurrence of an element within a certain area.\n     *\n     * @param {Array} position - The position of the area [x, y].\n     * @param {Array} size - The size of the area [columns, rows].\n     * @param {iteratorCallback} callback - The callback function that is called on each element within the defined area. Should return true if the element is found or false if not.\n     * @returns {(Array.<number>|undefined)} The position of the first element that is found or <code>undefined</code> if nothing was found.\n     */\n    this.findInArea = (position, size, callback) => _findInArea(this, _columns, position, size, callback);\n\n    /**\n     * Exports a copy of the internal data as two-dimensional array.\n     *\n     * @returns {Array.<Array.<*>>} The data as two-dimensional array.\n     */\n    this.data = () => _toArray2D(_data, _columns);\n\n    /**\n     * Rotate the array in a 90 degree steps. A positive step turns it clockwise, a negative step turns it counterclockwise.\n     *\n     * @param {number} steps - The number of 90 degree turns as integer number.\n     * @returns {gridl} The same gridl instance.\n     */\n    this.rotate = steps => {\n        const grid = _rotate(this.data(), _columns, steps);\n        _data = _flatten(grid);\n        _rows = grid.length;\n        _columns = grid[0].length;\n        return this;\n    };\n\n    /**\n     * Flips the array on the given x-position\n     *\n     * @param {number} xPos - The x-position of where to flip the array.\n     * @returns {gridl} The same gridl instance.\n     */\n    this.mirrorX = xPos => {\n        _data = _flatten(_mirror(this.data(), xPos));\n        return this;\n    };\n\n    /**\n     * Flips the array on the given y-position.\n     *\n     * @param {number} yPos - The y-position of where to flip the array.\n     * @returns {gridl} The same gridl instance.\n     */\n    this.mirrorY = yPos => {\n        const grid = this.data();\n        _data = _flatten(grid.map(row => _mirror(row, yPos)));\n        return this;\n    };\n\n    /**\n     * Go to an absolute position.\n     * The internal cursor will be set to this position and can then be used for further operations.\n     *\n     * @param {Array} position - The new position.\n     * @returns {gridl}\n     */\n    this.goto = position => {\n        const pos = _goto(_columns, _rows, position);\n        _position[0] = pos[0];\n        _position[1] = pos[1];\n        return this;\n    };\n\n    /**\n     * Walk in a given direction based on the current position.\n     *\n     * @param {Array} direction - The direction you want to go. (It's the position relative to the current position)\n     * @returns {gridl} The same gridl instance.\n     */\n    this.walk = direction => {\n        const pos = _walk(_columns, _rows, _position, direction);\n        _position[0] = pos[0];\n        _position[1] = pos[1];\n        return this;\n    };\n\n    /**\n     * Get the current position.\n     *\n     * @returns {Array} The current position array [column, row].\n     */\n    this.position = () => [\n        _position[0],\n        _position[1],\n    ];\n\n    /**\n     * Map over all cells. It's the equivalent of Array.map just for the grid.\n     *\n     * @param {iteratorCallback} callback - The callback function that is called on each cell.<br><code>function(cell, position, gridlInstance) { return ... }</code>\n     * @returns {gridl} A new gridl instance.\n     */\n    this.map = callback => {\n        const newData = _data.map((v, i) => callback(v, _index2pos(i, _columns), this));\n        return new gridl(_toArray2D(newData, _columns));\n    };\n\n    /**\n     * Iterate over all cells. It's the equivalent of Array.forEach just for the grid.\n     *\n     * @param {iteratorCallback} callback - The callback function is called for each cell.<br><code>function(cell, position, gridlInstance) { return ... }</code>\n     * @returns {gridl} The same gridl instance.\n     */\n    this.forEach = callback => {\n        _data.forEach((v, i) => callback(v, _index2pos(i, _columns), this));\n        return this;\n    };\n\n    /**\n     * Applies a function against an accumulator and each element in the grid to reduce it to a single value.\n     *\n     * @param {reducerCallback} callback - The callback function that is executed on each cell.<br><code>function(accumulator, cell, position, gridlInstance) { return ... }</code>\n     * @param {*} [initialValue=undefined] - Value to use as the first argument to the first call of the <code>callback</code>. If no initial value is supplied, the first element in the grid will be used.\n     * @returns {*} The value that results from the reduction.\n     */\n    this.reduce = function(callback, initialValue) {\n        const reducer = (acc, v, i) => callback(acc, v, _index2pos(i, _columns), this);\n        return arguments.length === 1 ? _data.reduce(reducer) : _data.reduce(reducer, initialValue);\n    };\n\n    /**\n     * Applies a function against an accumulator and each element in the area at a given position to reduce it to a single value.\n     *\n     * @param {number[][]} position - The position of the area within the grid.\n     * @param {number[][]} size - The size of the area within the grid.\n     * @param {reducerCallback} callback - The callback function that is executed on each cell within the grid.\n     * @param {*} [initialValue=undefined] - Value to use as the first argument to the first call of the <code>callback</code>. If no initial value is supplied, the first element in the grid will be used.\n     * @returns {*} The value that results from the reduction.\n     */\n    this.reduceAreaAt = function(position, size, callback, initialValue) {\n        return _reduceAreaAt(this, _columns, _rows, position, size, callback, initialValue, arguments.length === 1);\n    };\n\n    /**\n     * Applies a function against an accumulator and each element in the area at the current position to reduce it to a single value.\n     *\n     * @param {number[][]} size - The size of the area within the grid.\n     * @param {reducerCallback} callback - The callback function that is executed on each cell within the grid.\n     * @param {*} [initialValue=undefined] - Value to use as the first argument to the first call of the <code>callback</code>. If no initial value is supplied, the first element in the grid will be used.\n     * @returns {*} The value that results from the reduction.\n     */\n    this.reduceArea = function(size, callback, initialValue) {\n        return _reduceAreaAt(this, _columns, _rows, _position, size, callback, initialValue, arguments.length === 1);\n    };\n\n    /**\n     * Make a clone of the current gridl instance.\n     *\n     * @returns {gridl} A new gridl instance.\n     */\n    this.clone = () => new gridl(_toArray2D(_data, _columns)).goto(_position);\n\n    /**\n     * Get the values of all adjacent cells at a given position.\n     *\n     * @param {number[]} position - The position of the cell of which you want to know its adjacent cells.\n     * @param {number[][]} [adjacence = [adjacents.ALL]{@link adjacences}] - A list of positions relative to the given position. These positions are considered as the adjacents.\n     * @param {boolean} [includeOutsideValues = false] - If <code>false</code>, adjacent cells that are outside the grid will be ignored, if <code>true</code>, <code>undefined</code> will be returned for them.\n     * @returns {Array.<*>} The values of the adjacent cells.\n     */\n    this.adjacentCellsAt = (position, adjacence = adjacences.ALL, includeOutsideValues = false) => {\n        const gridSize = !includeOutsideValues && [_columns, _rows];\n        const grid = _toArray2D(_data, _columns);\n        return _adjacentCells(grid, position, adjacence, gridSize);\n    };\n\n    /**\n     * Get the values of all adjacent cells at the current position.<br>\n     * The current position can be defined by [goto(position)]{@link gridl#goto} or [walk(direction)]{@link gridl#walk}.\n     *\n     * @param {number[][]} [adjacence = [adjacents.ALL]{@link adjacences}] - A list of positions relative to the given position. These positions are considered as the adjacents.\n     * @param {boolean} [includeOutsideValues = false] - If <code>false</code>, adjacent cells that are outside the grid will be ignored, if <code>true</code>, <code>undefined</code> will be returned for them.\n     * @returns {Array.<*>} The values of the adjacent cells.\n     */\n    this.adjacentCells = (adjacence = adjacences.ALL, includeOutsideValues = false) => {\n        const gridSize = !includeOutsideValues && [_columns, _rows];\n        const grid = _toArray2D(_data, _columns);\n        return _adjacentCells(grid, _position, adjacence, gridSize);\n    };\n\n    /**\n     * Exports all entries as an one dimensional array.\n     *\n     * @returns {Array.<*>}\n     */\n    this.list = () => ([..._data]);\n\n    return this;\n\n}\n\n/**\n * Predefined directions you can walk in.<br>\n * Use it in combination with [walk(direction)]{@link gridl#walk}.\n *\n * @type {Object}\n * @property {Array.<number>} UP - one step up\n * @property {Array.<number>} UP_LEFT - one step left, one step up\n * @property {Array.<number>} UP_RIGHT - one step right, one step up\n * @property {Array.<number>} RIGHT - one step right\n * @property {Array.<number>} LEFT - one step left\n * @property {Array.<number>} DOWN - one step down\n * @property {Array.<number>} DOWN_LEFT - one step left, one step down\n * @property {Array.<number>} DOWN_RIGHT - one step right, one step down\n */\nexport const directions = Object.freeze({\n    UP:         Object.freeze([ 0, -1]),\n    UP_RIGHT:   Object.freeze([ 1, -1]),\n    RIGHT:      Object.freeze([ 1,  0]),\n    DOWN_RIGHT: Object.freeze([ 1,  1]),\n    DOWN:       Object.freeze([ 0,  1]),\n    DOWN_LEFT:  Object.freeze([-1,  1]),\n    LEFT:       Object.freeze([-1,  0]),\n    UP_LEFT:    Object.freeze([-1, -1]),\n});\n\n/**\n * Predefined lists of adjacent positions relative to a certain position.\n *\n * @type {Object}\n * @property {number[][]} ALL - all direct adjacent positions (orthogonal + diagonal) in the order: left to right, top to bottom\n * @property {number[][]} ALL_CW - all direct adjacent positions (orthogonal + diagonal) in clockwise order\n * @property {number[][]} ALL_CCW - all direct adjacent positions (orthogonal + diagonal) in counterclockwise order\n * @property {number[][]} ORTHOGONAL - all orthogonal adjacent positions in the order: left to right, top to bottom\n * @property {number[][]} ORTHOGONAL_CW - all orthogonal adjacent positions in clockwise order\n * @property {number[][]} ORTHOGONAL_CCW - all orthogonal adjacent positions in counterclockwise order\n * @property {number[][]} DIAGONAL - all diagonal adjacent positions in the order: left to right, top to bottom\n * @property {number[][]} DIAGONAL_CW - all diagonal adjacent positions in clockwise order\n * @property {number[][]} DIAGONAL_CCW - all diagonal adjacent positions in counterclockwise order\n */\nexport const adjacences = Object.freeze({\n    ALL: Object.freeze([\n        directions.UP_LEFT,\n        directions.UP,\n        directions.UP_RIGHT,\n        directions.LEFT,\n        directions.RIGHT,\n        directions.DOWN_LEFT,\n        directions.DOWN,\n        directions.DOWN_RIGHT,\n    ]),\n    ALL_CW: Object.freeze([\n        directions.UP,\n        directions.UP_RIGHT,\n        directions.RIGHT,\n        directions.DOWN_RIGHT,\n        directions.DOWN,\n        directions.DOWN_LEFT,\n        directions.LEFT,\n        directions.UP_LEFT,\n    ]),\n    ALL_CCW: Object.freeze([\n        directions.UP,\n        directions.UP_LEFT,\n        directions.LEFT,\n        directions.DOWN_LEFT,\n        directions.DOWN,\n        directions.DOWN_RIGHT,\n        directions.RIGHT,\n        directions.UP_RIGHT,\n    ]),\n    ORTHOGONAL: Object.freeze([\n        directions.UP,\n        directions.LEFT,\n        directions.RIGHT,\n        directions.DOWN,\n    ]),\n    ORTHOGONAL_CW: Object.freeze([\n        directions.UP,\n        directions.RIGHT,\n        directions.DOWN,\n        directions.LEFT,\n    ]),\n    ORTHOGONAL_CCW: Object.freeze([\n        directions.UP,\n        directions.LEFT,\n        directions.DOWN,\n        directions.RIGHT,\n    ]),\n    DIAGONAL: Object.freeze([\n        directions.UP_LEFT,\n        directions.UP_RIGHT,\n        directions.DOWN_LEFT,\n        directions.DOWN_RIGHT,\n    ]),\n    DIAGONAL_CW: Object.freeze([\n        directions.UP_RIGHT,\n        directions.DOWN_RIGHT,\n        directions.DOWN_LEFT,\n        directions.UP_LEFT,\n    ]),\n    DIAGONAL_CCW: Object.freeze([\n        directions.UP_LEFT,\n        directions.DOWN_LEFT,\n        directions.DOWN_RIGHT,\n        directions.UP_RIGHT,\n    ]),\n});\n\n/**\n * Create a two dimensional grid array.\n *\n * @param {number} columns - The number of columns.\n * @param {number} rows - The number of rows.\n * @param {Function} callback - The generator function that is called on each cell.\n * @returns {Array.<Array.<*>>} The new grid array.\n */\nexport function makeGrid(columns, rows, callback = () => null) {\n    const parsedColumns = parseInt(columns);\n    const parsedRows = parseInt(rows);\n    if (parsedColumns < 1 || isNaN(parsedColumns)) {\n        throw new Error(`You need to specify at least one column. Given: ${columns}`);\n    }\n    if (parsedRows < 1 || isNaN(parsedRows)) {\n        throw new Error(`You need to specify at least one row. Given: ${rows}`);\n    }\n    return Array.from({ length: parsedRows }, (vr, row) => (\n        Array.from({ length: parsedColumns }, (vc, column) => (\n            callback({ column, row })\n        ))\n    ));\n}\n\n/**\n * Generate a one-dimensional array that can be a single row or column.\n *\n * @param {number} length - The length of the array.\n * @param {Function} callback - The generator callback function that is called on each element.\n * @returns {Array.<*>}\n */\nexport function makeList(length, callback = () => null) {\n    const parsedLength = parseInt(length);\n    if (parsedLength < 1 || isNaN(parsedLength)) {\n        throw new Error(`Trying to make a list with an invalid length. Given: ${length}`);\n    }\n    return Array.from({ length: parsedLength }, (v, i) => callback(i));\n}\n\n/**\n * Generate a gridl instance from scratch by specifying the number of rows and columns and fill it with values.\n *\n * @param {number} numColumns - The number of columns.\n * @param {number} numRows - The number of rows.\n * @param {Function} callback - The generator function that is called for each cell. The returned value is going to be the value of the cell.\n * @returns {gridl} A new gridl instance\n */\nexport function make(numColumns, numRows, callback) {\n    return new gridl(makeGrid(numColumns, numRows, callback));\n}\n\n/**\n * Creates a new gridl instance.<br>\n * <br>\n * This is exported as the default function. It serves as a wrapper around gridl so that you don't have to use the <code>`new`</code>\n * keyword each time. So instead of saying `<code>new gridl(data)</code>` you can just say `<code>gridl(data)</code>`.\n * That's the only reason for gridlFactory.<br>\n * <br>\n * Please don't care too much about the difference between gridl and gridlFactory. Just use it as `<code>gridl(data)</code>`.\n *\n * @constructor\n * @param {Array.<Array.<*>>} data - A two dimensional grid array. Every row needs to have the same length.\n * @returns {gridl}\n */\nconst gridlFactory = data => new gridl(data);\ngridlFactory.adjacences = adjacences;\ngridlFactory.directions = directions;\ngridlFactory.make = make;\ngridlFactory.makeGrid = makeGrid;\ngridlFactory.makeList = makeList;\n\nexport default gridlFactory;\n\n\n\n// WEBPACK FOOTER //\n// ./src/index.js"],"sourceRoot":""}